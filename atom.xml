<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>梧雨北辰的博客</title>
  
  <subtitle>约定未来，不忘初心！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-31T14:34:40.555Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zhou Shuai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ReactiveCocoa函数响应式编程-应用篇</title>
    <link href="http://yoursite.com/2018/04/03/ReactiveCocoa%E5%87%BD%E6%95%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B-%E5%BA%94%E7%94%A8%E7%AF%87/"/>
    <id>http://yoursite.com/2018/04/03/ReactiveCocoa函数响应式编程-应用篇/</id>
    <published>2018-04-03T06:58:39.000Z</published>
    <updated>2018-08-31T14:34:40.555Z</updated>
    
    <content type="html"><![CDATA[<p>使用RAC其实就是一个创建信号订阅信号的过程。上篇<a href="https://www.jianshu.com/p/ba90d649ecb8" target="_blank" rel="noopener">ReactiveCocoa函数响应式编程-基础篇</a>，主要简单介绍了RAC的信号机制，本篇则以信号为核心，就信号常用的类、操作信号的方法，替换响应处理等方面总结RAC的使用。</p><a id="more"></a><h1 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h1><p>一、RAC中常用的类<br>二、RAC中常用的宏<br>三、RAC中信号的常用操作<br>四、RAC常用的处理事件响应的方法<br>五、本篇总结</p><p><strong>本篇还提供了关于RAC使用的两个测试工程，结合代码学习更加直观</strong>：<br><a href="https://github.com/DreamcoffeeZS/ReactiveCocoaDemo" target="_blank" rel="noopener">项目1</a>：<br>1.测试RAC对信号的各类操作。<br>2.使用RAC改进一个普通的登录界面。<br><a href="https://github.com/DreamcoffeeZS/MVVMReactiveCocoa" target="_blank" rel="noopener">项目2</a>：<br>MVVM架构结合RAC响应式编程的开发示例。实现登录界面和的分页数据界面。效果图如下：<br><img src="https://upload-images.jianshu.io/upload_images/1244124-34473c827d2898b5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="RAC&amp;&amp;MVVM实现一个登录界面和一个分页数据表视图界面"></p><h1 id="一、RAC中常用的类"><a href="#一、RAC中常用的类" class="headerlink" title="一、RAC中常用的类"></a>一、RAC中常用的类</h1><h4 id="1-RACSubject"><a href="#1-RACSubject" class="headerlink" title="1.RACSubject"></a>1.RACSubject</h4><p>RACSubject是信号RACSignal的一个子类，但它的底部实现与RACSignal有所不同。其订阅信号subscribeNext的方法只是使用nextBlock创建了一个订阅者并保存起来待用，多次调用subscribeNext会保存多个订阅者。<strong>只有发送信号sendNext方法执行时，订阅者才会执行nextBlock里的内容，多个订阅者会执行多次</strong>。<br>使用示例：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建信号</span></span><br><span class="line"><span class="comment">//创建RACSubject不需要block参数</span></span><br><span class="line">RACSubject *subject = [RACSubject subject];</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.订阅信号</span></span><br><span class="line"><span class="comment">//这里信号被订阅两次，那么订阅者也创建了两次，保存在RACSubject的subscribers属性数组中。</span></span><br><span class="line"><span class="comment">//那么每当信号有新值发出的时候，每个订阅者都会执行。    </span></span><br><span class="line">[subject subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="comment">//block在信号发出新值时调用</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第一个订阅者:%@"</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[subject subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第二个订阅者:%@"</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//3.发送信号</span></span><br><span class="line">[subject sendNext:<span class="string">@"6”];</span></span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">13</span>:<span class="number">07</span>:<span class="number">51.425569</span>+<span class="number">0800</span> ZSTest[<span class="number">2840</span>:<span class="number">124915</span>] 第一个订阅者:<span class="number">6</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">13</span>:<span class="number">07</span>:<span class="number">51.426113</span>+<span class="number">0800</span> ZSTest[<span class="number">2840</span>:<span class="number">124915</span>] 第二个订阅者:<span class="number">6</span></span><br></pre></td></tr></table></figure><p>应用示例：<strong>替换代理</strong><br>我们测试这样一个功能：在当前视图控制器A中点击按钮调转到下一视图控制器B，在B的文本框中输入内容，点击编辑完成按钮回到A，显示B中输入的内容到A的UILabel上。通常我们使用代理来解决这样的问题，那么现在我们可以利用RACSubject的特性来代替常用的代理的功能，其实就跟我们使用block回调一样。具体代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.下一视图控制中添加RACSubject属性。</span></span><br><span class="line"><span class="comment">//SecondViewController.h文件</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SecondViewController</span> : <span class="title">BaseViewController</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) RACSubject *racSubject;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.点击编辑完成按钮时，检查代理信号并发送消息，这里传递出一个字典(包含输入的文字)</span></span><br><span class="line"><span class="comment">//SecondViewController.m文件</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)completeBtnClick:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">self</span>.racSubject)&#123;</span><br><span class="line">        [<span class="keyword">self</span>.racSubject sendNext:@&#123;<span class="string">@"text"</span>:<span class="keyword">self</span>.txtField.text&#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.navigationController popViewControllerAnimated:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3.当前视图控制器A的跳转按钮响应方法中，创建secondVC，并为其添加信号属性和订阅信号。</span></span><br><span class="line"><span class="comment">//TestViewCotroller.m文件</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)testBtnClick:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    SecondViewController *secondVC = [[SecondViewController alloc] initWithNibName:<span class="string">@"SecondViewController"</span> bundle:<span class="literal">nil</span>];</span><br><span class="line">   <span class="comment">//为secondVC设置RACSubject属性，并订阅信号</span></span><br><span class="line">    secondVC.racSubject = [RACSubject subject];</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    <span class="comment">//定阅信号的block会更新文字的显示</span></span><br><span class="line">    [secondVC.racSubject subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSDictionary</span> *infoDic =(<span class="built_in">NSDictionary</span> *)x;</span><br><span class="line">        weakSelf.showLabel.text =  infoDic[<span class="string">@"text"</span>];</span><br><span class="line">    &#125;];</span><br><span class="line">    [<span class="keyword">self</span>.navigationController pushViewController:secondVC animated:<span class="literal">YES</span>];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="2-RACTuple与RACSequence"><a href="#2-RACTuple与RACSequence" class="headerlink" title="2.RACTuple与RACSequence"></a>2.RACTuple与RACSequence</h4><p><strong>RACTuple</strong>：类似OC的数组，是RAC中用来封装值的元组类，可以配合RACTupleUnpack解元组。<br><strong>RACSequeue</strong>：数组和字典经过rac_sequence方法会被转化为RACSequeue类型，并进一步转为我们常用的信号。订阅此类信号的时候，信号就会被激活并遍历其中的所有值。</p><p>使用示例：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历数组</span></span><br><span class="line"><span class="built_in">NSArray</span> *characters = @[<span class="string">@"A"</span>,<span class="string">@"C"</span>,<span class="string">@"B"</span>,<span class="string">@"E"</span>,<span class="string">@"D"</span>];</span><br><span class="line">    [characters.rac_sequence.signal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"char:%@"</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">控制台打印：</span><br><span class="line"><span class="keyword">char</span>:A</span><br><span class="line"><span class="keyword">char</span>:C</span><br><span class="line"><span class="keyword">char</span>:B</span><br><span class="line"><span class="keyword">char</span>:E</span><br><span class="line"><span class="keyword">char</span>:D</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历字典</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *myInfoDic = @&#123;<span class="string">@"name"</span>:<span class="string">@"zs"</span>,<span class="string">@"nickname"</span>:<span class="string">@"FengZi"</span>,<span class="string">@"age"</span>:<span class="string">@"18"</span>&#125;;\</span><br><span class="line">[myInfoDic.rac_sequence.signal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">//解元组，注意一一对应</span></span><br><span class="line">    RACTupleUnpack(<span class="built_in">NSString</span> *key,<span class="built_in">NSString</span> *value) = x;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"myInfoDic:%@-%@"</span>,key,value);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">控制台打印：</span><br><span class="line">myInfoDic:name-zs</span><br><span class="line">myInfoDic:nickname-FengZi</span><br><span class="line">myInfoDic:age<span class="number">-18</span></span><br></pre></td></tr></table></figure><h4 id="3-RACMulticastConnection"><a href="#3-RACMulticastConnection" class="headerlink" title="3.RACMulticastConnection"></a>3.RACMulticastConnection</h4><p>RACMulticastConnection用于解决一个信号被多次订阅后，创建信号中的block被重复调用的问题，所以在实际开发中，使用RACMulticastConnection可以解决网络重复请求的问题。<br>测试1:普通的信号</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"发送信号A"</span>);</span><br><span class="line">   [subscriber sendNext:<span class="string">@"发送信号A"</span>];</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[signalA subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"第一次订阅：%@"</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"> [signalA subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"第二次订阅：%@"</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-28</span> <span class="number">10</span>:<span class="number">02</span>:<span class="number">00.702607</span>+<span class="number">0800</span> ZSTest[<span class="number">2446</span>:<span class="number">48444</span>] 发送信号A</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-28</span> <span class="number">10</span>:<span class="number">02</span>:<span class="number">00.702856</span>+<span class="number">0800</span> ZSTest[<span class="number">2446</span>:<span class="number">48444</span>] 第一次订阅：发送信号A</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-28</span> <span class="number">10</span>:<span class="number">02</span>:<span class="number">00.703069</span>+<span class="number">0800</span> ZSTest[<span class="number">2446</span>:<span class="number">48444</span>] 发送信号A</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-28</span> <span class="number">10</span>:<span class="number">02</span>:<span class="number">00.703325</span>+<span class="number">0800</span> ZSTest[<span class="number">2446</span>:<span class="number">48444</span>] 第二次订阅：发送信号A</span><br></pre></td></tr></table></figure><p>测试2：使用RACMulticastConnection</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建信号</span></span><br><span class="line">RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"发送信号B"</span>);</span><br><span class="line">    [subscriber sendNext:<span class="string">@"发送信号B"</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//2.连接信号：publish或者muticast方法</span></span><br><span class="line"><span class="comment">//连接后的信号使用订阅方法时，并不能激活信号，而是将其订阅者保存到数组中。</span></span><br><span class="line"><span class="comment">//在连接对象执行connect方法时，信号中的订阅者会统一调用sendNext方法。</span></span><br><span class="line">RACMulticastConnection *signalBconnect = [signalB publish];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//3.订阅信号</span></span><br><span class="line"><span class="comment">//使用signalBconnect而不再是signalB</span></span><br><span class="line">[signalBconnect.signal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第一次订阅：%@"</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line">[signalBconnect.signal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第二次订阅：%@"</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.连接后激活信号</span></span><br><span class="line">[signalBconnect connect];</span><br><span class="line"></span><br><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-28</span> <span class="number">10</span>:<span class="number">02</span>:<span class="number">00.704209</span>+<span class="number">0800</span> ZSTest[<span class="number">2446</span>:<span class="number">48444</span>] 发送信号B</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-28</span> <span class="number">10</span>:<span class="number">02</span>:<span class="number">00.704368</span>+<span class="number">0800</span> ZSTest[<span class="number">2446</span>:<span class="number">48444</span>] 第一次订阅：发送信号B</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-28</span> <span class="number">10</span>:<span class="number">02</span>:<span class="number">00.704543</span>+<span class="number">0800</span> ZSTest[<span class="number">2446</span>:<span class="number">48444</span>] 第二次订阅：发送信号B</span><br></pre></td></tr></table></figure><h1 id="4-RACCommand：用于处理事件的类"><a href="#4-RACCommand：用于处理事件的类" class="headerlink" title="4.RACCommand：用于处理事件的类"></a>4.RACCommand：用于处理事件的类</h1><p>RACCommand可以把事件如何处理，如何传递都封装到类中，之后就可以方便的调起它的执行方法。在实际开发中，我们可以用它来封装一个网络操作。<br>注意：<br>1.创建方法中block返回一个信号，且不能为nil，但是可以使用[RACSignal empty]表示空信号<br>2.RACCommand必须被强引用，否则容易被释放</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建RACCommand：initWithSignalBlock</span></span><br><span class="line"><span class="keyword">self</span>.command = [[RACCommand alloc] initWithSignalBlock:^RACSignal * _Nonnull(<span class="keyword">id</span>  _Nullable input) &#123;</span><br><span class="line">    <span class="comment">//我们常在这里创建一个网络请求的信号，也就是封装一个请求数据的操作。</span></span><br><span class="line">    RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:<span class="string">@"网络请求的信号"</span>];</span><br><span class="line">        <span class="comment">//数据传递完成，必须调用sendComplleted.,否则永远处于执行中。</span></span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="keyword">return</span> signal;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//2.订阅RACCommand中的信号，要等到RACCommand执行后，才能收到消息</span></span><br><span class="line">[<span class="keyword">self</span>.command.executionSignals subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">//这里是一个信号中信号</span></span><br><span class="line">    [x subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"收到信号：%@"</span>,x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//改进订阅方法：switchToLatest可以直接获取信号中信号</span></span><br><span class="line">[<span class="keyword">self</span>.command.executionSignals.switchToLatest subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"改进-收到信号：%@"</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//3.监听RACCommand命令是否执行完毕的信号</span></span><br><span class="line"><span class="comment">//默认会监测一次，所以可以使用skip表示跳过第一次信号。</span></span><br><span class="line"><span class="comment">//这里可以用于App网络请求时，控制加载提示视图的隐藏或者显示</span></span><br><span class="line">[[<span class="keyword">self</span>.command.executing skip:<span class="number">1</span>] subscribeNext:^(<span class="built_in">NSNumber</span> * _Nullable x) &#123;</span><br><span class="line">    <span class="keyword">if</span>([x boolValue] == <span class="literal">YES</span>)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"RACCommand命令正在执行..."</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"RACCommand命令不在执行中！！！"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//4.执行RACComand</span></span><br><span class="line"><span class="comment">//方法：- (RACSignal *)execute:(id)input</span></span><br><span class="line">[<span class="keyword">self</span>.command execute:<span class="string">@""</span>];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">14</span>:<span class="number">43</span>:<span class="number">06.571968</span>+<span class="number">0800</span> ZSTest[<span class="number">3725</span>:<span class="number">171859</span>] RACCommand命令正在执行...</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">14</span>:<span class="number">43</span>:<span class="number">06.572526</span>+<span class="number">0800</span> ZSTest[<span class="number">3725</span>:<span class="number">171859</span>] 收到信号：网络请求的信号</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">14</span>:<span class="number">43</span>:<span class="number">06.572662</span>+<span class="number">0800</span> ZSTest[<span class="number">3725</span>:<span class="number">171859</span>] 改进-收到信号：网络请求的信号</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">14</span>:<span class="number">43</span>:<span class="number">06.573506</span>+<span class="number">0800</span> ZSTest[<span class="number">3725</span>:<span class="number">171859</span>] RACCommand命令不在执行中！！！</span><br></pre></td></tr></table></figure><h1 id="二、RAC常用的宏定义"><a href="#二、RAC常用的宏定义" class="headerlink" title="二、RAC常用的宏定义"></a>二、RAC常用的宏定义</h1><h4 id="1-RAC-对象，对象属性-：绑定属性"><a href="#1-RAC-对象，对象属性-：绑定属性" class="headerlink" title="1.RAC(对象，对象属性)：绑定属性"></a>1.RAC(对象，对象属性)：绑定属性</h4><p>输入框背景色绑定了映射后的validUserNameSignal信号，信号变化时背景色更新</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RAC(<span class="keyword">self</span>.userNameTxtField,backgroundColor) = [validUserNameSignal map:^<span class="keyword">id</span> _Nullable(<span class="built_in">NSNumber</span> *userNameValid) &#123;</span><br><span class="line">    <span class="keyword">return</span> [userNameValid boolValue] ? [<span class="built_in">UIColor</span> whiteColor] : [<span class="built_in">UIColor</span> yellowColor];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="2-RACObserve-被观察的对象，被观察对象的属性-：代替KVO监听某个对象的某个属性"><a href="#2-RACObserve-被观察的对象，被观察对象的属性-：代替KVO监听某个对象的某个属性" class="headerlink" title="2.RACObserve(被观察的对象，被观察对象的属性) ：代替KVO监听某个对象的某个属性"></a>2.RACObserve(被观察的对象，被观察对象的属性) ：代替KVO监听某个对象的某个属性</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[RACObserve(<span class="keyword">self</span>.view, backgroundColor) subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"测试：%@"</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">//颜色变化时将打印</span></span><br><span class="line"><span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line"><span class="keyword">self</span>.view.backgroundColor =[<span class="built_in">UIColor</span> redColor];</span><br></pre></td></tr></table></figure><h4 id="3-RACTuplePack与RACTupleUnpack"><a href="#3-RACTuplePack与RACTupleUnpack" class="headerlink" title="3.RACTuplePack与RACTupleUnpack"></a>3.RACTuplePack与RACTupleUnpack</h4><p><strong>RACTuplePack</strong>：将数据封装成元组<br><strong>RACTupleUnpack</strong>：将元组解包为数据</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用RACTuplePack封装元组</span></span><br><span class="line">RACTuple *racTuple = RACTuplePack(<span class="string">@"字符串1"</span>,<span class="string">@"字符串2"</span>);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"测试racTuple:%@"</span>,racTuple);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用RACTupleUnpack解元组</span></span><br><span class="line">RACTupleUnpack(<span class="built_in">NSString</span> *str1,<span class="built_in">NSString</span> *str2) = racTuple;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"测试RACTupleUnpack：%@-%@"</span>,str1,str2);</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-26</span> <span class="number">19</span>:<span class="number">27</span>:<span class="number">27.568399</span>+<span class="number">0800</span> ZSTest[<span class="number">23113</span>:<span class="number">380213</span>] 测试racTuple:&lt;RACTwoTuple: <span class="number">0x60400000ed70</span>&gt; (</span><br><span class="line">    <span class="string">"\U5b57\U7b26\U4e321"</span>,</span><br><span class="line">    <span class="string">"\U5b57\U7b26\U4e322"</span></span><br><span class="line">)</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-26</span> <span class="number">19</span>:<span class="number">27</span>:<span class="number">27.568623</span>+<span class="number">0800</span> ZSTest[<span class="number">23113</span>:<span class="number">380213</span>] 测试RACTupleUnpack：字符串<span class="number">1</span>-字符串<span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="4-weakify、-strongify"><a href="#4-weakify、-strongify" class="headerlink" title="4.@weakify、@strongify"></a>4.@weakify、@strongify</h4><p>RAC中使用@weakify、@strongify解决Block循环引用的问题。<strong>在block内部使用@strongify(self)后就可以使用self操作属性了，但是一定注意这两个宏定义一定要配合使用</strong>，<a href="https://www.jianshu.com/p/701da54bd78c" target="_blank" rel="noopener">可参考源码分析</a>。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@weakify(<span class="keyword">self</span>);</span><br><span class="line"><span class="comment">//RAC处理手势，点击页面，隐藏键盘</span></span><br><span class="line">[<span class="keyword">self</span>.tapGesture.rac_gestureSignal subscribeNext:^(__kindof <span class="built_in">UIGestureRecognizer</span> * _Nullable x) &#123;</span><br><span class="line">    @strongify(<span class="keyword">self</span>);</span><br><span class="line">    <span class="comment">//经过宏定义处理后就可以使用self了，但此self非彼self。具体可查看源码分析</span></span><br><span class="line">    [<span class="keyword">self</span>.view endEditing:<span class="literal">YES</span>];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h1 id="三、RAC中关于信号的常用操作"><a href="#三、RAC中关于信号的常用操作" class="headerlink" title="三、RAC中关于信号的常用操作"></a>三、RAC中关于信号的常用操作</h1><p>本节整理了以下几种常用信号操作：<br>1.信号映射：map与flattenMap<br>2.信号过滤：filter、ignore、 distinctUntilChanged<br>3.信号合并： combineLatest、reduce、merge、zipWith<br>4.信号连接：concat、then<br>5.信号操作时间：timeout、interval、dely<br>6.信号取值：take、takeLast、takeUntil、<br>7.信号跳过：skip<br>8.信号发送顺序：donext、cocompleted<br>9.获取信号中的信号：switchToLatest<br>10.信号错误重试：retry<br>11.信号节流：throttle<br>12.信号操作多线程：deliverON、subscribeOn</p><h4 id="一、信号映射：map与flattenMap"><a href="#一、信号映射：map与flattenMap" class="headerlink" title="一、信号映射：map与flattenMap"></a>一、信号映射：map与flattenMap</h4><p><strong>map</strong>：将信号内容修改为另一种新值。改变了传递的值<br><strong>flattenMap</strong>：将源信号映射修改为另一种新的信号。修改了信号本身</p><h5 id="1-map"><a href="#1-map" class="headerlink" title="1.map"></a>1.map</h5><p>将信号文本值修改为文本长度</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//block中return的是你希望接收到的值</span></span><br><span class="line">[[<span class="keyword">self</span>.txtField.rac_textSignal map:^<span class="keyword">id</span> _Nullable(<span class="built_in">NSString</span> * _Nullable value) &#123;</span><br><span class="line">    <span class="keyword">return</span> @(value.length);<span class="comment">//必须返回一个对象</span></span><br><span class="line">&#125;] subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">     <span class="comment">//输入abcd，打印了输入字符的长度</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"打印x:%@"</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">10</span>:<span class="number">52</span>:<span class="number">41.831785</span>+<span class="number">0800</span> ZSTest[<span class="number">1143</span>:<span class="number">44274</span>] 打印x:<span class="number">1</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">10</span>:<span class="number">52</span>:<span class="number">42.575238</span>+<span class="number">0800</span> ZSTest[<span class="number">1143</span>:<span class="number">44274</span>] 打印x:<span class="number">2</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">10</span>:<span class="number">52</span>:<span class="number">43.602008</span>+<span class="number">0800</span> ZSTest[<span class="number">1143</span>:<span class="number">44274</span>] 打印x:<span class="number">3</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">10</span>:<span class="number">52</span>:<span class="number">44.054940</span>+<span class="number">0800</span> ZSTest[<span class="number">1143</span>:<span class="number">44274</span>] 打印x:<span class="number">4</span></span><br></pre></td></tr></table></figure><h5 id="2-flattenMap"><a href="#2-flattenMap" class="headerlink" title="2.flattenMap"></a>2.flattenMap</h5><p>flattenMap的block返回的是你想要的信号</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个普通信号</span></span><br><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@"发送信号：1"</span>];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个发送信号的信号，信号的信号</span></span><br><span class="line">RACSignal *signalOfSignals = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:signal];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//订阅信号中的信号</span></span><br><span class="line">[signalOfSignals subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">//不使用flattenMap，会打印出内部信号</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"订阅signalOfSignals：%@"</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">[[signalOfSignals flattenMap:^__kindof RACSignal * _Nullable(<span class="keyword">id</span>  _Nullable value) &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">   &#125;] subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">//使用flattenMap，会打印内部信号的值</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"使用flattenMap后订阅signalOfSignals：%@"</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">11</span>:<span class="number">23</span>:<span class="number">42.920455</span>+<span class="number">0800</span> ZSTest[<span class="number">1363</span>:<span class="number">61658</span>] 订阅signalOfSignals：&lt;RACDynamicSignal: <span class="number">0x60400023a320</span>&gt; name: </span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">11</span>:<span class="number">23</span>:<span class="number">42.920791</span>+<span class="number">0800</span> ZSTest[<span class="number">1363</span>:<span class="number">61658</span>] 使用flattenMap后订阅signalOfSignals：发送信号：<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>特别说明：信号中信号常出现在我们封装一个网络请求为信号的时候，这时候注意flattenMap的使用。</strong></p><h4 id="二、信号过滤：filter、ignore、-distinctUntilChanged"><a href="#二、信号过滤：filter、ignore、-distinctUntilChanged" class="headerlink" title="二、信号过滤：filter、ignore、 distinctUntilChanged"></a>二、信号过滤：filter、ignore、 distinctUntilChanged</h4><h5 id="1-filter"><a href="#1-filter" class="headerlink" title="1.filter"></a>1.filter</h5><p>过滤信号，符合条件的信号才能发出消息。<br>示例：输入1234，当输入到4(文本长度大于3)的时候才开始打印如下的信息</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="keyword">self</span>.txtField.rac_textSignal filter:^<span class="built_in">BOOL</span>(<span class="built_in">NSString</span> * _Nullable value) &#123;</span><br><span class="line">    <span class="keyword">return</span> value.length &gt; <span class="number">3</span>;</span><br><span class="line">    &#125;] subscribeNext:^(<span class="built_in">NSString</span> * _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"打印x：%@"</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">11</span>:<span class="number">39</span>:<span class="number">23.371432</span>+<span class="number">0800</span> ZSTest[<span class="number">1428</span>:<span class="number">68939</span>] 打印x：<span class="number">1234</span></span><br></pre></td></tr></table></figure><h5 id="2-ignore"><a href="#2-ignore" class="headerlink" title="2.ignore"></a>2.ignore</h5><p>忽略信号，针对信号值的某一种状态进行忽略，忽略时不会发送消息。<br>示例：监听每次的输入，但是当文本框内的内容是”a”时不会打印</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="keyword">self</span>.txtField.rac_textSignal ignore:<span class="string">@"a"</span>] subscribeNext:^(<span class="built_in">NSString</span> * _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"ignore测试打印：%@"</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h5 id="3-distinctUntilChanged"><a href="#3-distinctUntilChanged" class="headerlink" title="3.distinctUntilChanged"></a>3.distinctUntilChanged</h5><p>当上次的值与当前值有变化时才会发出消息，否则信息被忽略</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为了方便测试，我们监测控制器的currentText属性来修改Label的文本值。</span></span><br><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</span><br><span class="line">[[RACObserve(<span class="keyword">self</span>, currentText) distinctUntilChanged] subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"使用%@更新testLabel的值"</span>,x);</span><br><span class="line">    weakSelf.testLabel.text = x;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//currentTxt未被赋初值，所以第一次打印null,我们自己修改三次值，只打印两次</span></span><br><span class="line"><span class="keyword">self</span>.currentText = <span class="string">@"hello"</span>;</span><br><span class="line"><span class="keyword">self</span>.currentText = <span class="string">@"world"</span>;</span><br><span class="line"><span class="keyword">self</span>.currentText = <span class="string">@"world"</span>;</span><br><span class="line"></span><br><span class="line">控制台打印:</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">43</span>:<span class="number">54.617385</span>+<span class="number">0800</span> ZSTest[<span class="number">3598</span>:<span class="number">220992</span>] 使用(null)更新testLabel的值</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">43</span>:<span class="number">54.618026</span>+<span class="number">0800</span> ZSTest[<span class="number">3598</span>:<span class="number">220992</span>] 使用hello更新testLabel的值</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">43</span>:<span class="number">54.618380</span>+<span class="number">0800</span> ZSTest[<span class="number">3598</span>:<span class="number">220992</span>] 使用world更新testLabel的值</span><br></pre></td></tr></table></figure><h4 id="三、信号合并：combineLatest、reduce、merge、zipWith"><a href="#三、信号合并：combineLatest、reduce、merge、zipWith" class="headerlink" title="三、信号合并：combineLatest、reduce、merge、zipWith"></a>三、信号合并：combineLatest、reduce、merge、zipWith</h4><p>为了便于测试，这里先创建两个RACSubject类型的信号用于测试，此类信号只有发送信号sendNext方法执行时，订阅者才会执行nextBlock里的内容;</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RACSubject *signalOne = [RACSubject subject];</span><br><span class="line">[signalOne subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"订阅信号one：%@"</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSubject *signalTwo = [RACSubject subject];</span><br><span class="line">[signalTwo subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"订阅信号Two：%@"</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h5 id="1-combineLatest：合并信号"><a href="#1-combineLatest：合并信号" class="headerlink" title="1. combineLatest：合并信号"></a>1. combineLatest：合并信号</h5><p>合并信号的效果就是，这多个信号都至少有过一次订阅信号sendNext的操作，才会触发合并的信号。下面的测试如果只有signalOne执行sendNext方法，那么combineLatest后的信号不会被触发。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[RACSignal combineLatest:@[signalOne,signalTwo]] subscribeNext:^(RACTuple * _Nullable x) &#123;</span><br><span class="line">    <span class="comment">//解元组：合并信号得到的是一个元组,里面存放的是两个信号发送的消息</span></span><br><span class="line">    RACTupleUnpack(<span class="built_in">NSString</span> *str1,<span class="built_in">NSString</span> *str2) = x;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"combineLatest:str1-%@,str2-%@"</span>,str1,str2);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[signalOne sendNext:<span class="string">@"1"</span>];</span><br><span class="line">[signalTwo sendNext:<span class="string">@"2”];</span></span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">14</span>:<span class="number">29</span>:<span class="number">53.198724</span>+<span class="number">0800</span> ZSTest[<span class="number">2172</span>:<span class="number">143774</span>] 订阅信号one：<span class="number">1</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">14</span>:<span class="number">29</span>:<span class="number">53.199673</span>+<span class="number">0800</span> ZSTest[<span class="number">2172</span>:<span class="number">143774</span>] 订阅信号Two：<span class="number">2</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">14</span>:<span class="number">29</span>:<span class="number">53.200075</span>+<span class="number">0800</span> ZSTest[<span class="number">2172</span>:<span class="number">143774</span>] combineLatest:&lt;RACTuple: <span class="number">0x60000000d9a0</span>&gt; (</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    <span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h5 id="2-reduce：聚合信号"><a href="#2-reduce：聚合信号" class="headerlink" title="2. reduce：聚合信号"></a>2. reduce：聚合信号</h5><p>combineLatest合并后的信号订阅后，得到的是一个元组(包含每个被合并信号的新值)。然而在开发中，我们往往需要检测多个信号合并后的效果(比如用户名和密码信号有效时，登录按钮才可以点击)，这里就用到了reduce来实现信号聚合。<br>reduce聚合操作中的block参数个数随合并信号的数量而定，有多少个信号被合并，blcok中的参数就有多少个。这些参数一一对应被合并的信号，是它们对应的新值。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[[RACSignal combineLatest:@[signalOne,signalTwo] reduce:^<span class="keyword">id</span>(<span class="built_in">NSString</span> *strOne,<span class="built_in">NSString</span> *strTwo)&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@-%@"</span>,strOne,strTwo];</span><br><span class="line">&#125;] subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"combineLatest-reduce：%@"</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line">[signalOne sendNext:<span class="string">@"1"</span>];</span><br><span class="line">[signalTwo sendNext:<span class="string">@"2"</span>];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">14</span>:<span class="number">40</span>:<span class="number">08.977580</span>+<span class="number">0800</span> ZSTest[<span class="number">2288</span>:<span class="number">149816</span>] 订阅信号one：<span class="number">1</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">14</span>:<span class="number">40</span>:<span class="number">08.978566</span>+<span class="number">0800</span> ZSTest[<span class="number">2288</span>:<span class="number">149816</span>] 订阅信号Two：<span class="number">2</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">14</span>:<span class="number">40</span>:<span class="number">08.979587</span>+<span class="number">0800</span> ZSTest[<span class="number">2288</span>:<span class="number">149816</span>] combineLatest-reduce：<span class="number">1</span><span class="number">-2</span></span><br></pre></td></tr></table></figure><h5 id="3-merge：合并信号"><a href="#3-merge：合并信号" class="headerlink" title="3. merge：合并信号"></a>3. merge：合并信号</h5><p>当合并后的信号被订阅时，就会订阅里面所有的信号<br>测试1：将多个信号合并之后，当其中任何一个信号发送消息时，都能被监测到。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *mergeSignal = [signalOne merge:signalTwo];</span><br><span class="line">[mergeSignal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"mergeSignal：%@"</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">//只调用其中一个信号,就会触发merge合并的信号</span></span><br><span class="line">[signalOne sendNext:<span class="string">@"测试信号1"</span>];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">14</span>:<span class="number">53</span>:<span class="number">34.342899</span>+<span class="number">0800</span> ZSTest[<span class="number">2577</span>:<span class="number">160009</span>] 订阅信号one：测试信号<span class="number">1</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">14</span>:<span class="number">53</span>:<span class="number">34.343124</span>+<span class="number">0800</span> ZSTest[<span class="number">2577</span>:<span class="number">160009</span>] mergeSignal：测试信号<span class="number">1</span></span><br></pre></td></tr></table></figure><p>测试2：当合并后的信号被订阅时，就会订阅里面所有的信号</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal1 = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@"signal1"</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *signal2 = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@"signal2"</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *mergeSignals = [signal1 merge:signal2];</span><br><span class="line">    [mergeSignals subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"mergeSignals：%@"</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">18</span>:<span class="number">10</span>:<span class="number">29.623099</span>+<span class="number">0800</span> ZSTest[<span class="number">4444</span>:<span class="number">270816</span>] mergeSignals：signal1</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">18</span>:<span class="number">10</span>:<span class="number">29.623721</span>+<span class="number">0800</span> ZSTest[<span class="number">4444</span>:<span class="number">270816</span>] mergeSignals：signal2</span><br></pre></td></tr></table></figure><h5 id="4-zipWith：压缩信号"><a href="#4-zipWith：压缩信号" class="headerlink" title="4. zipWith：压缩信号"></a>4. zipWith：压缩信号</h5><p>1.zipWith把两个信号压缩成为一个信号。<br>2.只有当两个信号同时发出信号时，两个信号的内容才会被合并为一个元组，触发压缩流的next事件。比如：当一个界面多个请求的时候，要等所有请求完成才更新UI。元组内元素顺序只与压缩信号的顺序有关，与发送信号的顺序无关。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *zipSignal = [signalOne zipWith:signalTwo];</span><br><span class="line">[zipSignal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">//解元组：合并信号得到的是一个元组,里面存放的是两个信号发送的消息</span></span><br><span class="line">    RACTupleUnpack(<span class="built_in">NSString</span> *str1,<span class="built_in">NSString</span> *str2) = x;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"zipSignal：str1-%@,str2-%@"</span>,str1,str2);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[signalOne sendNext:<span class="string">@"测试zipSignalMsgOne"</span>];</span><br><span class="line">[signalTwo sendNext:<span class="string">@"测试zipSignalMsgTwo"</span>];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">15</span>:<span class="number">23</span>:<span class="number">58.989780</span>+<span class="number">0800</span> ZSTest[<span class="number">2926</span>:<span class="number">177798</span>] 订阅信号one：测试zipSignalMsgOne</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">15</span>:<span class="number">23</span>:<span class="number">58.990012</span>+<span class="number">0800</span> ZSTest[<span class="number">2926</span>:<span class="number">177798</span>] 订阅信号Two：测试zipSignalMsgTwo</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">15</span>:<span class="number">23</span>:<span class="number">58.991056</span>+<span class="number">0800</span> ZSTest[<span class="number">2926</span>:<span class="number">177798</span>] zipSignal：str1-测试zipSignalMsgOne,str2-测试zipSignalMsgTwo</span><br></pre></td></tr></table></figure><h4 id="四、信号拼接：concat、then"><a href="#四、信号拼接：concat、then" class="headerlink" title="四、信号拼接：concat、then"></a>四、信号拼接：concat、then</h4><h5 id="1-concat"><a href="#1-concat" class="headerlink" title="1.concat"></a>1.concat</h5><p>1.使用concat可以按序拼接多个信号，拼接后的信号按序执行。<br>2.使用concat连接信号后，每个信号无需再单独订阅，其内部会按序自动订阅<br>3.前面的信号必须执行sendCompleted，后面的信号才会被激活</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signalOne = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@"signalOne"</span>];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">RACSignal *signalTwo = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@"signalTwo"</span>];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *signalThree = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@"signalThree"</span>];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">   </span><br><span class="line"><span class="comment">//拼接了三个信号，订阅之后，三个信号依次激活</span></span><br><span class="line">RACSignal *concatSignal = [[signalOne concat:signalThree] concat:signalTwo];</span><br><span class="line">[concatSignal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"信号被激活:%@"</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-22</span> <span class="number">17</span>:<span class="number">36</span>:<span class="number">47.565105</span>+<span class="number">0800</span> ZSTest[<span class="number">6018</span>:<span class="number">274201</span>] 信号被激活:signalOne</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-22</span> <span class="number">17</span>:<span class="number">36</span>:<span class="number">47.565403</span>+<span class="number">0800</span> ZSTest[<span class="number">6018</span>:<span class="number">274201</span>] 信号被激活:signalThree</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-22</span> <span class="number">17</span>:<span class="number">36</span>:<span class="number">47.565609</span>+<span class="number">0800</span> ZSTest[<span class="number">6018</span>:<span class="number">274201</span>] 信号被激活:signalTwo</span><br></pre></td></tr></table></figure><h5 id="2-then-连接信号"><a href="#2-then-连接信号" class="headerlink" title="2.then:连接信号"></a>2.then:连接信号</h5><p>使用then连接信号，上一个信号完成后，才会连接then返回的信号，所以then连接的上一个信号必须使用sendCompleted，否则后续信号无法执行。<br><strong>then连接的多个信号与concat不同的是：之前的信号会被忽略掉，即订阅信号只会接收到最后一个信号的值</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[[[[RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"信号1"</span>);</span><br><span class="line">        [subscriber sendNext:<span class="string">@"发送信号1"</span>];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;] then:^RACSignal *&#123;</span><br><span class="line">        <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"信号2"</span>);</span><br><span class="line">            [subscriber sendNext:<span class="string">@"发送信号2"</span>];</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;]then:^RACSignal * _Nonnull&#123;</span><br><span class="line">        <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"信号3"</span>);</span><br><span class="line">            [subscriber sendNext:<span class="string">@"发送信号3"</span>];</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;] subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">        <span class="comment">//只能接收到最后一个信号的值</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"订阅信号：%@"</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">53</span>:<span class="number">52.819003</span>+<span class="number">0800</span> ZSTest[<span class="number">3668</span>:<span class="number">227466</span>] 信号<span class="number">1</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">53</span>:<span class="number">52.819762</span>+<span class="number">0800</span> ZSTest[<span class="number">3668</span>:<span class="number">227466</span>] 信号<span class="number">2</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">53</span>:<span class="number">52.820008</span>+<span class="number">0800</span> ZSTest[<span class="number">3668</span>:<span class="number">227466</span>] 信号<span class="number">3</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">53</span>:<span class="number">52.820139</span>+<span class="number">0800</span> ZSTest[<span class="number">3668</span>:<span class="number">227466</span>] 订阅信号：发送信号<span class="number">3</span></span><br></pre></td></tr></table></figure><h4 id="五、信号操作时间：timeout、interval、dely"><a href="#五、信号操作时间：timeout、interval、dely" class="headerlink" title="五、信号操作时间：timeout、interval、dely"></a>五、信号操作时间：timeout、interval、dely</h4><h5 id="1-interval"><a href="#1-interval" class="headerlink" title="1. interval"></a>1. interval</h5><p>创建定时器信号，每固定时间发送一次信号</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *intervalSignal = [RACSignal interval:<span class="number">1</span> onScheduler:[RACScheduler currentScheduler]];</span><br><span class="line"></span><br><span class="line"><span class="comment">//只知道使用take结束定时器这一种方法，不知道还有没有其他方法</span></span><br><span class="line">[[intervalSignal take:<span class="number">5</span>]subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">//订阅定时器信号，启动定时器，只打印5次</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"interval,定时器打印"</span>);</span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure><h5 id="2-timeout"><a href="#2-timeout" class="headerlink" title="2.timeout"></a>2.timeout</h5><p>可以设置超时操作，让一个信号在规定时间之后自动报错<br><strong>创建信号时不能使用sendCompleted，因为这样的话一旦发送了消息就取消订阅了。</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *timeOutSignal = [[RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@"timeOutSignal发送信号"</span>];</span><br><span class="line">    <span class="comment">//[subscriber sendCompleted];</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;] timeout:<span class="number">5</span> onScheduler:[RACScheduler currentScheduler]];</span><br><span class="line">   </span><br><span class="line">[timeOutSignal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"timeOutSignal:%@"</span>,x);</span><br><span class="line"> &#125; error:^(<span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">    <span class="comment">//5秒后执行打印：</span></span><br><span class="line">    <span class="comment">//timeOutSignal:出现Error-Error Domain=RACSignalErrorDomain Code=1 "(null)"</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"timeOutSignal:出现Error-%@"</span>,error);</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"timeOutSignal:complete"</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h5 id="3-delay"><a href="#3-delay" class="headerlink" title="3.delay"></a>3.delay</h5><p>延迟发送sendNext</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *delaySignal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@"delaySignal-sendNext"</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">   </span><br><span class="line"><span class="comment">//10秒后才收到消息，执行打印</span></span><br><span class="line">[[delaySignal delay:<span class="number">10</span>] subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"delaySignal:%@"</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="六、信号取值take、takeLast、takeUntil"><a href="#六、信号取值take、takeLast、takeUntil" class="headerlink" title="六、信号取值take、takeLast、takeUntil"></a>六、信号取值take、takeLast、takeUntil</h4><p>首先创建一个signal来测试这三个方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@"发送消息1"</span>];</span><br><span class="line">    [subscriber sendNext:<span class="string">@"发送消息2"</span>];</span><br><span class="line">    [subscriber sendNext:<span class="string">@"发送消息3"</span>];</span><br><span class="line">    [subscriber sendNext:<span class="string">@"发送消息4"</span>];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h5 id="1-take：从开始共取N次的next值"><a href="#1-take：从开始共取N次的next值" class="headerlink" title="1.take：从开始共取N次的next值"></a>1.take：从开始共取N次的next值</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[[signal take:<span class="number">2</span>] subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"订阅信号:%@"</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">15</span>:<span class="number">09.865290</span>+<span class="number">0800</span> ZSTest[<span class="number">3835</span>:<span class="number">237999</span>] 订阅信号:发送消息<span class="number">1</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">15</span>:<span class="number">09.865617</span>+<span class="number">0800</span> ZSTest[<span class="number">3835</span>:<span class="number">237999</span>] 订阅信号:发送消息<span class="number">2</span></span><br></pre></td></tr></table></figure><h5 id="2-takeLast：从最后共取值N次next的值"><a href="#2-takeLast：从最后共取值N次next的值" class="headerlink" title="2.takeLast：从最后共取值N次next的值"></a>2.takeLast：从最后共取值N次next的值</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[signal takeLast:<span class="number">3</span>]subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"订阅信号：%@"</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">19</span>:<span class="number">51.343909</span>+<span class="number">0800</span> ZSTest[<span class="number">3933</span>:<span class="number">241042</span>] 订阅信号：发送消息<span class="number">2</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">19</span>:<span class="number">51.344063</span>+<span class="number">0800</span> ZSTest[<span class="number">3933</span>:<span class="number">241042</span>] 订阅信号：发送消息<span class="number">3</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">19</span>:<span class="number">51.344177</span>+<span class="number">0800</span> ZSTest[<span class="number">3933</span>:<span class="number">241042</span>] 订阅信号：发送消息<span class="number">4</span></span><br></pre></td></tr></table></figure><h5 id="3-takeUntil-RACSignal"><a href="#3-takeUntil-RACSignal" class="headerlink" title="3.takeUntil:(RACSignal *)"></a>3.takeUntil:(RACSignal *)</h5><p>使用RACSubject类型的信号来测试，直到某个信号执行完成  ,才获取信号</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">RACSubject *signalA = [RACSubject subject];</span><br><span class="line"></span><br><span class="line">[signalA subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"订阅信号A：%@"</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</span><br><span class="line"><span class="comment">//[RACObserve(self, currentText)发送消息知道signalA信号结束</span></span><br><span class="line">[[RACObserve(<span class="keyword">self</span>, currentText) takeUntil:signalA] subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"使用%@更新testLabel的值"</span>,x);</span><br><span class="line">    weakSelf.testLabel.text = x;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.currentText = <span class="string">@"0"</span>;</span><br><span class="line"><span class="keyword">self</span>.currentText = <span class="string">@"1"</span>;</span><br><span class="line"><span class="keyword">self</span>.currentText = <span class="string">@"2"</span>;</span><br><span class="line">[signalA sendCompleted];<span class="comment">//信号A结束之后，监听testLabel文本的信号也不在发送消息了</span></span><br><span class="line"><span class="keyword">self</span>.currentText = <span class="string">@"3"</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"代码执行到此行。。。。"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">31</span>:<span class="number">08.907925</span>+<span class="number">0800</span> ZSTest[<span class="number">4044</span>:<span class="number">247412</span>] 使用(null)更新testLabel的值</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">31</span>:<span class="number">08.908531</span>+<span class="number">0800</span> ZSTest[<span class="number">4044</span>:<span class="number">247412</span>] 使用<span class="number">0</span>更新testLabel的值</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">31</span>:<span class="number">08.908957</span>+<span class="number">0800</span> ZSTest[<span class="number">4044</span>:<span class="number">247412</span>] 使用<span class="number">1</span>更新testLabel的值</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">31</span>:<span class="number">08.909194</span>+<span class="number">0800</span> ZSTest[<span class="number">4044</span>:<span class="number">247412</span>] 使用<span class="number">2</span>更新testLabel的值</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">31</span>:<span class="number">08.909725</span>+<span class="number">0800</span> ZSTest[<span class="number">4044</span>:<span class="number">247412</span>] 代码执行到此行。。。。</span><br></pre></td></tr></table></figure><h4 id="七、信号跳过：skip"><a href="#七、信号跳过：skip" class="headerlink" title="七、信号跳过：skip"></a>七、信号跳过：skip</h4><p>使用skip跳过几个信号</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@"第一次发送消息"</span>];</span><br><span class="line">    [subscriber sendNext:<span class="string">@"第二次发送消息"</span>];</span><br><span class="line">    [subscriber sendNext:<span class="string">@"第三次发送消息"</span>];</span><br><span class="line">    [subscriber sendNext:<span class="string">@"第四次发送消息"</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[[signal skip:<span class="number">2</span>] subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">48</span>:<span class="number">06.479104</span>+<span class="number">0800</span> ZSTest[<span class="number">4284</span>:<span class="number">259095</span>] 第三次发送消息</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">48</span>:<span class="number">06.479376</span>+<span class="number">0800</span> ZSTest[<span class="number">4284</span>:<span class="number">259095</span>] 第四次发送消息</span><br></pre></td></tr></table></figure><h4 id="八、信号发送顺序：doNext、doCompleted"><a href="#八、信号发送顺序：doNext、doCompleted" class="headerlink" title="八、信号发送顺序：doNext、doCompleted"></a>八、信号发送顺序：doNext、doCompleted</h4><p>发送信号前与发送信号后操作：doNext、doCompleted<br><strong>doNext</strong>：在订阅者发送消息sendNext之前执行<br><strong>doCompleted</strong>：在订阅者发送完成sendCompleted之后执行</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@"发送信号：1"</span>];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">[[[signal doNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"执行doNext"</span>);</span><br><span class="line">&#125;] doCompleted:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"执行doComplete"</span>);</span><br><span class="line">&#125;] subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"订阅信号：%@"</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-28</span> <span class="number">11</span>:<span class="number">20</span>:<span class="number">42.881535</span>+<span class="number">0800</span> ZSTest[<span class="number">2656</span>:<span class="number">81106</span>] 执行doNext</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-28</span> <span class="number">11</span>:<span class="number">20</span>:<span class="number">42.881841</span>+<span class="number">0800</span> ZSTest[<span class="number">2656</span>:<span class="number">81106</span>] 订阅信号：发送信号：<span class="number">1</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-28</span> <span class="number">11</span>:<span class="number">20</span>:<span class="number">42.882583</span>+<span class="number">0800</span> ZSTest[<span class="number">2656</span>:<span class="number">81106</span>] 执行doComplete</span><br></pre></td></tr></table></figure><h4 id="九、获取信号中的信号：switchToLatest"><a href="#九、获取信号中的信号：switchToLatest" class="headerlink" title="九、获取信号中的信号：switchToLatest"></a>九、获取信号中的信号：switchToLatest</h4><p>switchToLatest只能用于信号中的信号(否则崩溃)，获取最新发送的信号。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个普通信号</span></span><br><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@"发送信号：1"</span>];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个发送信号的信号，信号的信号</span></span><br><span class="line">RACSignal *signalOfSignals = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:signal];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//订阅最近发出的信号</span></span><br><span class="line">[signalOfSignals.switchToLatest subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">//控制台打印：switchToLatest打印：发送信号：1</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"switchToLatest打印：%@"</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>特别说明：<br><strong>可以看出switchToLatest和flattenMap的功能很相似，但是它们有一主要区别：</strong></p><h4 id="十、信号错误重试：retry"><a href="#十、信号错误重试：retry" class="headerlink" title="十、信号错误重试：retry"></a>十、信号错误重试：retry</h4><p>retry：只要失败就重新执行信号</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> signalANum = <span class="number">0</span>;</span><br><span class="line">RACSignal *signalA = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    <span class="keyword">if</span> (signalANum == <span class="number">5</span>) &#123;</span><br><span class="line">        [subscriber sendNext:<span class="string">@"signalANum is 5"</span>];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"signalANum错误！！!"</span>);</span><br><span class="line">        [subscriber sendError:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    signalANum++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">  </span><br><span class="line">[[signalA retry] subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"StringA-Next：%@"</span>,x);</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">    <span class="comment">//特别注意：这里并没有打印</span></span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"signalA-Errror"</span>);</span><br><span class="line">&#125;] ;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">09</span>:<span class="number">46</span>:<span class="number">38.996888</span>+<span class="number">0800</span> ZSTest[<span class="number">818</span>:<span class="number">14322</span>] signalANum错误！！!</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">09</span>:<span class="number">46</span>:<span class="number">39.063427</span>+<span class="number">0800</span> ZSTest[<span class="number">818</span>:<span class="number">14322</span>] signalANum错误！！!</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">09</span>:<span class="number">46</span>:<span class="number">39.064203</span>+<span class="number">0800</span> ZSTest[<span class="number">818</span>:<span class="number">14322</span>] signalANum错误！！!</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">09</span>:<span class="number">46</span>:<span class="number">39.064567</span>+<span class="number">0800</span> ZSTest[<span class="number">818</span>:<span class="number">14322</span>] signalANum错误！！!</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">09</span>:<span class="number">46</span>:<span class="number">39.064819</span>+<span class="number">0800</span> ZSTest[<span class="number">818</span>:<span class="number">14322</span>] signalANum错误！！!</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">09</span>:<span class="number">46</span>:<span class="number">39.065199</span>+<span class="number">0800</span> ZSTest[<span class="number">818</span>:<span class="number">14322</span>] StringA-Next：signalANum is <span class="number">5</span></span><br></pre></td></tr></table></figure><h4 id="十一、信号节流：throttle"><a href="#十一、信号节流：throttle" class="headerlink" title="十一、信号节流：throttle"></a>十一、信号节流：throttle</h4><p>当某个信号发送比较频繁时，可以使用throttle节流，在某一段时间不发送信号内容，过了一段时间获取信号的最新内容发出。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[[[RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:<span class="string">@"发送消息11"</span>];</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [subscriber sendNext:<span class="string">@"发送消息21"</span>];</span><br><span class="line">            [subscriber sendNext:<span class="string">@"发送消息22"</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">        </span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">3</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [subscriber sendNext:<span class="string">@"发送消息31"</span>];</span><br><span class="line">            [subscriber sendNext:<span class="string">@"发送消息32"</span>];</span><br><span class="line">            [subscriber sendNext:<span class="string">@"发送消息33"</span>];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">4</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [subscriber sendNext:<span class="string">@"发送消息41"</span>];</span><br><span class="line">            [subscriber sendNext:<span class="string">@"发送消息42"</span>];</span><br><span class="line">            [subscriber sendNext:<span class="string">@"发送消息43"</span>];</span><br><span class="line">            [subscriber sendNext:<span class="string">@"发送消息44"</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;    </span><br><span class="line">&#125;] throttle:<span class="number">2</span>] subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Next:%@"</span>,x);</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">11</span>:<span class="number">05</span>:<span class="number">48.411464</span>+<span class="number">0800</span> ZSTest[<span class="number">2063</span>:<span class="number">62521</span>] Next:发送消息<span class="number">11</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">11</span>:<span class="number">05</span>:<span class="number">52.426162</span>+<span class="number">0800</span> ZSTest[<span class="number">2063</span>:<span class="number">62521</span>] Next:发送消息<span class="number">44</span></span><br></pre></td></tr></table></figure><h4 id="十二、信号关于线程的操作"><a href="#十二、信号关于线程的操作" class="headerlink" title="十二、信号关于线程的操作"></a>十二、信号关于线程的操作</h4><p><strong>副作用</strong>：关于信号与线程,我们把在创建信号时block中的代码称之为副作用。<br><strong>deliverON</strong>：切换到指定线程中，可用于回到主线中刷新UI,内容传递切换到指定线程中，<br><strong>subscribeOn</strong>：内容传递和副作用都会切换到指定线程中。<br><strong>deliverOnMainThread</strong>：能保证原信号subscribeNext，sendError，sendCompleted都在主线程MainThread中执行。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试1：系统并行队列中异步执行,未使用deliverON切换线程</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        [[RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">            [subscriber sendNext:<span class="string">@"测试1-endNext"</span>];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"测试1-当前线程：%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;] subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"测试1-Next:%@"</span>,x);</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"测试1-Next当前线程：%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;) ;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//测试2：系统并行队列中异步执行,使用deliverON切换线程</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        [[[RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">            [subscriber sendNext:<span class="string">@"测试2-endNext"</span>];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"测试2-当前线程：%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;] deliverOn:[RACScheduler mainThreadScheduler]] subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"测试2-Next:%@"</span>,x);</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"测试2-Next当前线程：%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;) ;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//测试3：系统并行队列中异步执行,使用subscribeOn切换线程</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        [[[RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">            [subscriber sendNext:<span class="string">@"测试3-sendNext"</span>];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"测试3-sendNext当前线程：%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;] subscribeOn:[RACScheduler mainThreadScheduler]] subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"测试3-Next:%@"</span>,x);</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"测试3-Next当前线程：%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;) ;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">48.025872</span>+<span class="number">0800</span> ZSTest[<span class="number">2624</span>:<span class="number">109537</span>] 测试<span class="number">1</span>-Next:测试<span class="number">1</span>-endNext</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">48.026152</span>+<span class="number">0800</span> ZSTest[<span class="number">2624</span>:<span class="number">109537</span>] 测试<span class="number">1</span>-Next当前线程：&lt;<span class="built_in">NSThread</span>: <span class="number">0x60400046e640</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">48.026746</span>+<span class="number">0800</span> ZSTest[<span class="number">2624</span>:<span class="number">109537</span>] 测试<span class="number">1</span>-sendNext当前线程：&lt;<span class="built_in">NSThread</span>: <span class="number">0x60400046e640</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">48.027784</span>+<span class="number">0800</span> ZSTest[<span class="number">2624</span>:<span class="number">109537</span>] 测试<span class="number">2</span>-sendNext当前线程：&lt;<span class="built_in">NSThread</span>: <span class="number">0x60400046e640</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">48.073294</span>+<span class="number">0800</span> ZSTest[<span class="number">2624</span>:<span class="number">109360</span>] 测试<span class="number">2</span>-Next:测试<span class="number">2</span>-sendNext</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">48.073890</span>+<span class="number">0800</span> ZSTest[<span class="number">2624</span>:<span class="number">109360</span>] 测试<span class="number">2</span>-Next当前线程：&lt;<span class="built_in">NSThread</span>: <span class="number">0x60400006a280</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">48.074181</span>+<span class="number">0800</span> ZSTest[<span class="number">2624</span>:<span class="number">109360</span>] 测试<span class="number">3</span>-Next:测试<span class="number">3</span>-sendNext</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">48.074511</span>+<span class="number">0800</span> ZSTest[<span class="number">2624</span>:<span class="number">109360</span>] 测试<span class="number">3</span>-Next当前线程：&lt;<span class="built_in">NSThread</span>: <span class="number">0x60400006a280</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-24</span> <span class="number">12</span>:<span class="number">37</span>:<span class="number">48.074646</span>+<span class="number">0800</span> ZSTest[<span class="number">2624</span>:<span class="number">109360</span>] 测试<span class="number">3</span>-sendNext当前线程：&lt;<span class="built_in">NSThread</span>: <span class="number">0x60400006a280</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br></pre></td></tr></table></figure><p>分析：<br><strong>测试1：未切换线程，发送消息与接收消息都在异步线程中</strong><br><strong>测试2：使用deliverON，发送消息还在原来的线程，但是接收消息切换到主线程。</strong><br><strong>测试2：使用subscribeON，发送消息和接收消息都被切换到了主线程中执行。</strong></p><h1 id="四、RAC常用的处理事件响应的方法"><a href="#四、RAC常用的处理事件响应的方法" class="headerlink" title="四、RAC常用的处理事件响应的方法"></a>四、RAC常用的处理事件响应的方法</h1><h4 id="1-代替代理的使用"><a href="#1-代替代理的使用" class="headerlink" title="1.代替代理的使用"></a>1.代替代理的使用</h4><p>基础篇里已经有一种使用RACSubject替换代理的方法，这里是另一种形式的替换。在视图控制中添加自定义视图CustomView，其上有一按钮testBtn添加了响应方法testBtnClick:。此时可以使用RAC在不使用代理的情况下，在视图控制中监听自定义视图中按钮的点击:<br><strong>关键方法：rac_signalForSelector</strong><br>使用说明：<br>1.通过rac_signalForSelector方法，以按钮响应方法为参数，得到一个信号。<br>2.订阅信号，在按钮点击时会发出信号。经过测试，即使testBtnClick方法没有在自定义视图的.h文件中声明，执行也是正常的。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[_customView  rac_signalForSelector:<span class="keyword">@selector</span>(testBtnClick:)] subscribeNext:^(RACTuple * _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"testBtn点击了。。。"</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="2-代替按钮等控制视图的响应事件"><a href="#2-代替按钮等控制视图的响应事件" class="headerlink" title="2.代替按钮等控制视图的响应事件"></a>2.代替按钮等控制视图的响应事件</h4><p>创建一个类似按钮的响应控件，我们可以不必再为其添加响应方法。使用RAC可以将按钮点击事件转化为信号，点击按钮会发送信号，执行订阅方法。<br><strong>关键方法：rac_signalForControlEvents</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[testBtn rac_signalForControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>] subscribeNext:^(__kindof <span class="built_in">UIControl</span> * _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"testBtn点击了。。。"</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="3-代替KVO，监听对象属性变化"><a href="#3-代替KVO，监听对象属性变化" class="headerlink" title="3.代替KVO，监听对象属性变化"></a>3.代替KVO，监听对象属性变化</h4><p><strong>关键方法：rac_valuesAndChangesForKeyPath</strong><br>使用说明：<br>1.自定义视图_customView属性frame的变化被转化信号，frame发生变化的时候，会发送信号。<br>2.observer可以为nil,但是会报警告。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[_customView rac_valuesAndChangesForKeyPath:<span class="string">@"frame"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> observer: <span class="literal">nil</span>] subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"CustomView的Frame值变化了：%@"</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line">_customView.frame = <span class="built_in">CGRectZero</span>;</span><br></pre></td></tr></table></figure><h4 id="4-监听文本输入变化"><a href="#4-监听文本输入变化" class="headerlink" title="4.监听文本输入变化"></a>4.监听文本输入变化</h4><p><strong>关键方法：rac_textSignal</strong><br>UITextField与UITextView输入视图内容的变化，我们也可以采用RAC的方法来监听</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[_testTxtView rac_textSignal] subscribeNext:^(<span class="built_in">NSString</span> * _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"当前文本输入内容：%@"</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="5-代替通知的使用"><a href="#5-代替通知的使用" class="headerlink" title="5.代替通知的使用"></a>5.代替通知的使用</h4><p><strong>关键方法：rac_addObserverForName</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//步骤1： 添加通知</span></span><br><span class="line">[[[<span class="built_in">NSNotificationCenter</span> defaultCenter] rac_addObserverForName:<span class="string">@"SecondVCNotificaitonName"</span> object:<span class="literal">nil</span>] subscribeNext:^(<span class="built_in">NSNotification</span> * _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *objectDic = (<span class="built_in">NSDictionary</span> *)x.object;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"获取到通知里的文本：%@"</span>,objectDic[<span class="string">@"text"</span>]);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//步骤2：发起通知</span></span><br><span class="line"><span class="comment">//SecondVC中点击按钮，将输入框中的文本封装成字典，将其作为参数发起通知</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)completeBtnClick:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:<span class="string">@"SecondVCNotificaitonName"</span> object:@&#123;<span class="string">@"text"</span>:<span class="keyword">self</span>.txtField.text&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-多请求汇总处理"><a href="#6-多请求汇总处理" class="headerlink" title="6.多请求汇总处理"></a>6.多请求汇总处理</h4><p><strong>关键方法：rac_liftSelector：withSignals：</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下载任务1</span></span><br><span class="line">RACSignal *downLoad1 = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@&#123;<span class="string">@"data2"</span>:<span class="string">@"value1"</span>&#125;];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//下载任务2</span></span><br><span class="line">RACSignal *downLoad2  = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@&#123;<span class="string">@"data2"</span>:<span class="string">@"value2"</span>&#125;];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//多信号对应多参数，注意顺序与格式</span></span><br><span class="line">[<span class="keyword">self</span> rac_liftSelector:<span class="keyword">@selector</span>(handleAllTasksWithT1:withT2:) withSignals:downLoad1,downLoad2, <span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//集中处理所有的请求</span></span><br><span class="line">- (<span class="keyword">void</span>)handleAllTasksWithT1:(<span class="keyword">id</span>)data1 withT2:(<span class="keyword">id</span>)data2&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"下载任务全部完成：%@，%@"</span>,data1,data2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五、本篇总结"><a href="#五、本篇总结" class="headerlink" title="五、本篇总结"></a>五、本篇总结</h1><p>写到这里，其实RAC还是有好多东西没有在这里涉及，本篇也只是对于它最常用的部分进行了归纳总结，尤其是我对于RAC在MVVM架构中的使用还不太熟练。RAC的学习，这仅仅是一个开始，继续努力吧！</p><p>参考链接：<br>1.<a href="http://ios.jobbole.com/86357/" target="_blank" rel="noopener">RAC核心元素与信号流</a><br>2.<a href="https://www.jianshu.com/p/a4fefb434652" target="_blank" rel="noopener">iOS常用API整理</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用RAC其实就是一个创建信号订阅信号的过程。上篇&lt;a href=&quot;https://www.jianshu.com/p/ba90d649ecb8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ReactiveCocoa函数响应式编程-基础篇&lt;/a&gt;，主要简单介绍了RAC的信号机制，本篇则以信号为核心，就信号常用的类、操作信号的方法，替换响应处理等方面总结RAC的使用。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="移动开发" scheme="http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
      <category term="Reactive" scheme="http://yoursite.com/tags/Reactive/"/>
    
  </entry>
  
  <entry>
    <title>ReactiveCocoa函数响应式编程-基础篇</title>
    <link href="http://yoursite.com/2018/04/03/ReactiveCocoa%E5%87%BD%E6%95%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B-%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <id>http://yoursite.com/2018/04/03/ReactiveCocoa函数响应式编程-基础篇/</id>
    <published>2018-04-03T06:34:57.000Z</published>
    <updated>2018-08-31T14:34:40.554Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h1><p>一、了解函数响应式编程<br>二、ReactiveCocoa简介<br>三、ReactiveCocoa集成<br>四、理解什么是信号<br>五、从源码理解RAC的信号机制<br>六、本篇总结<br><a id="more"></a></p><h1 id="一、了解函数响应式编程"><a href="#一、了解函数响应式编程" class="headerlink" title="一、了解函数响应式编程"></a>一、了解函数响应式编程</h1><p><img src="https://upload-images.jianshu.io/upload_images/1244124-613e9c9d4106f91b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><strong>函数式编程(Funcational Programming)</strong><br>使用高阶函数编程，即函数可采用多种函数作为它们的参数和返回值。</p><p><strong>响应式编程(Reactive Programming)</strong><br>一种面向数据流和变化传播的编程范式</p><p><strong>函数响应式编程(Funcational Reacitve Programming)</strong><br>简称FRP，ReactiveCocoa就是一个典型的FRP框架，响应式的编程思想，函数式的代码形式。</p><h1 id="二、ReactiveCocoa简介"><a href="#二、ReactiveCocoa简介" class="headerlink" title="二、ReactiveCocoa简介"></a>二、ReactiveCocoa简介</h1><p>ReactiveCocoa(简称RAC)，Reactive表示响应式，Cocoa是苹果整个框架的简称，许多苹果框架都以Cocoa结尾。所以RAC是Github上为我们提供函数响应式编程方法的iOS开发框架。</p><p>iOS开发中，我们需要使用按钮点击、代理、通知等这些方法来处理响应事件。而RAC框架使用Category为很多基本的UIKit控件添加信号Signal，这样我们可以通过信号来监听数据流与变化传播，把将监听的代码与处理代码放在一起，从而方便我们管理。利用此特点结合MVVM架构，RAC也有十分显著的作用。</p><h1 id="三、ReactiveCocoa集成"><a href="#三、ReactiveCocoa集成" class="headerlink" title="三、ReactiveCocoa集成"></a>三、ReactiveCocoa集成</h1><p>RAC.5.0相对于之前版本对于自身项目结构进行了较大调整，被拆分ReactiveCocoa、ReactiveSwift、ReactiveObjC、ReactiveObjCBridge四个库，我们需要根据不同的情况来集成。<br><a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="noopener">GitHub地址：https://github.com/ReactiveCocoa/ReactiveCocoa</a><br>通常，我们都使用Cocoapods集成RAC，<strong>需要注意的是Podfile文件中必须使用user_framework!</strong>，然后，针对于不同的代码环境，有三种集成情况：</p><h4 id="1-纯OC工程"><a href="#1-纯OC工程" class="headerlink" title="1.纯OC工程"></a>1.纯OC工程</h4><p>ReactiveObjc库包含原RAC2的全部代码，在纯OC工程中使用</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">platform :ios, '8.0'</span><br><span class="line">use_frameworks!     <span class="meta">#必须添加</span></span><br><span class="line">target 'ZSTest' do  #工程名</span><br><span class="line"><span class="meta">#pod 'ReactiveObjC' #默认导入最新的RAC版本         </span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="2-纯Swift工程"><a href="#2-纯Swift工程" class="headerlink" title="2.纯Swift工程"></a>2.纯Swift工程</h4><p>纯Swfit工程继续使用ReactiveCocoa，但RAC依赖ReactiveSwift，所以相当于引入两个库。<br>集成方法同上，只不过将ReactiveObjc换成ReactiveCocoa。</p><h4 id="3-OC与Swift混编工程"><a href="#3-OC与Swift混编工程" class="headerlink" title="3.OC与Swift混编工程"></a>3.OC与Swift混编工程</h4><p>混编工程需要同时引入ReactiveCocoa与ReactiveObjCBridge，但是ReactiveObjCBridge库依赖于ReactiveObjc库，所以相当于同时引入四个库了。示例如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">platform :ios, '8.0'</span><br><span class="line">use_frameworks!     <span class="meta">#必须添加</span></span><br><span class="line">target 'ZSTest' do  #工程名</span><br><span class="line">pod 'ReactiveCocoa'</span><br><span class="line">pod 'ReactiveObjC'  </span><br><span class="line">pod 'ReactiveObjCBridge'</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h1 id="四、ReactiveCocoa信号理解"><a href="#四、ReactiveCocoa信号理解" class="headerlink" title="四、ReactiveCocoa信号理解"></a>四、ReactiveCocoa信号理解</h1><p>我觉得学习RAC的第一个关口就是理解信号RACSignal了，什么是信号也许是困惑我们的第一个问题。</p><p>作为RAC中最为核心的一个类，<strong>信号可以理解为传递数据变化信息的工具</strong>，信号会在数据发生变化时发送事件流给它的订阅者，然后订阅者执行响应方法。信号本身不具备发送信号的能力，而是交给一个订阅者去发出。</p><p>首先上一段代码，演示信号的一个基本使用。<br>测试场景：我们要对一个用于输入用户名的UITextFiled进行检测，每次输入内容变化的时候都打出输入框的内容，使用RAC来实现此操作的关键代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.userNameTxtField.rac_textSignal subscribeNext:^(<span class="built_in">NSString</span> * _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"测试：%@"</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">控制台打印：</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">57</span>:<span class="number">00.497956</span>+<span class="number">0800</span> ZSTest[<span class="number">4351</span>:<span class="number">263810</span>] 测试：<span class="number">1</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">57</span>:<span class="number">00.498237</span>+<span class="number">0800</span> ZSTest[<span class="number">4351</span>:<span class="number">263810</span>] 测试：<span class="number">12</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">57</span>:<span class="number">00.498375</span>+<span class="number">0800</span> ZSTest[<span class="number">4351</span>:<span class="number">263810</span>] 测试：<span class="number">123</span></span><br></pre></td></tr></table></figure><p>没错的，不使用代理方法，也没有action的响应处理，我们仅仅使用了一行方法就实现了对文本框输入内容的实时打印。由此，RAC的实用性可见一斑。</p><h1 id="五、ReactiveCocoa信号机制"><a href="#五、ReactiveCocoa信号机制" class="headerlink" title="五、ReactiveCocoa信号机制"></a>五、ReactiveCocoa信号机制</h1><p>我们会对上面的代码产生疑问，RAC是怎么做到上述代码功能的呢？而且我们常说的订阅者又在哪里呢？</p><p>其实RAC已经使用Category的形式为我们基本的UI控件创建了信号(<strong>如上例中的rac_textSignal</strong>)，所以这里我们才可以很方便的实现信号订阅，而且订阅者在整个过程中也是对于我们隐藏的。 现在我们使用自定义信号的方法，从创建信号到订阅信号细致的了解一下这个过程。首先上一段创建信号的测试代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建信号</span></span><br><span class="line">RACSignal *testSignal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">    <span class="comment">//1.订阅者发送信号内容</span></span><br><span class="line">    [subscriber sendNext:<span class="string">@"发送信号内容"</span>];</span><br><span class="line">    <span class="comment">//2.订阅者发送信号完成的信息，不需要再发送数据时，最好发送信号完成，可以内部调起清理信号的操作。</span></span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="comment">//3.创建信号的Block参数，需要返回一个RACDisposable对象 ，可以返回nil。</span></span><br><span class="line">    <span class="comment">//RACDisposable对象用于取消订阅信号，此block在信号完成或者错误时调用。</span></span><br><span class="line">    RACDisposable *racDisposable = [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"信号Error或者Complete时销毁"</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="keyword">return</span> racDisposable;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//订阅信号</span></span><br><span class="line">[testSignal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="comment">//新变化的值</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"订阅信号：subscribeNext:%@"</span>,x);</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">    <span class="comment">//信号错误，被取消订阅,被移除观察</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"订阅信号：Error:%@"</span>,error.description);</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">    <span class="comment">//信号已经完成，被取消订阅，被移除观察</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"订阅信号：subscribeComplete"</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">控制台打印:</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">57</span>:<span class="number">00.497956</span>+<span class="number">0800</span> ZSTest[<span class="number">4351</span>:<span class="number">263810</span>] 订阅信号：subscribeNext:发送信号内容</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">57</span>:<span class="number">00.498237</span>+<span class="number">0800</span> ZSTest[<span class="number">4351</span>:<span class="number">263810</span>] 订阅信号：subscribeComplete</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-23</span> <span class="number">17</span>:<span class="number">57</span>:<span class="number">00.498375</span>+<span class="number">0800</span> ZSTest[<span class="number">4351</span>:<span class="number">263810</span>] 信号Error或者Complete时销毁</span><br></pre></td></tr></table></figure><p>我们通过观察源码来理解整个过程:</p><h4 id="1-创建信号"><a href="#1-创建信号" class="headerlink" title="1.创建信号"></a>1.创建信号</h4><p>创建信号，我们需要使用RACSignal的类方法createSignal。该方法需要一个Block作为参数。查看源码，我们就会发现RACSignal最终是通过调用自己子类RACDynamicSignal的createSignal方法，将这个Block设置给了自己的didSubscribe属性的。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RACSignal.m文件</span></span><br><span class="line">+ (RACSignal *)createSignal:(RACDisposable * (^)(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber))didSubscribe &#123;</span><br><span class="line"> <span class="keyword">return</span> [RACDynamicSignal createSignal:didSubscribe];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RACDynamicSignal.h文件</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACDynamicSignal</span> ()</span></span><br><span class="line"><span class="comment">// The block to invoke for each subscriber.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) RACDisposable * (^didSubscribe)(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber);</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RACDynamicSignal.m文件</span></span><br><span class="line">+ (RACSignal *)createSignal:(RACDisposable * (^)(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber))didSubscribe &#123;</span><br><span class="line"> RACDynamicSignal *signal = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line"> signal-&gt;_didSubscribe = [didSubscribe <span class="keyword">copy</span>];</span><br><span class="line"> <span class="keyword">return</span> [signal setNameWithFormat:<span class="string">@"+createSignal:"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>didSubscribe</strong>：这是创建信号时候需要传入的一个block，它的传入参数是订阅者subscriber，而返回值是需要是一个RACDisposable对象。创建信号后的didSubscrib是一个等待执行的block。</p><p><strong>RACSubscriber</strong>：表示订阅者，创建信号时订阅者发送信号，这里的订阅者是一个协议而非一个类。信号需要订阅者帮助其发送数据。查看RACSubscriber的协议，我可以看到以下几个方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送信息</span></span><br><span class="line">- (<span class="keyword">void</span>)sendNext:(<span class="keyword">nullable</span> <span class="keyword">id</span>)value;</span><br><span class="line"><span class="comment">//发送错误消息</span></span><br><span class="line">- (<span class="keyword">void</span>)sendError:(<span class="keyword">nullable</span> <span class="built_in">NSError</span> *)error;</span><br><span class="line"><span class="comment">//发送完成信息</span></span><br><span class="line">- (<span class="keyword">void</span>)sendCompleted;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">- (<span class="keyword">void</span>)didSubscribeWithDisposable:(RACCompoundDisposable *)disposable;</span><br></pre></td></tr></table></figure><p>在创建一个信号的时候，订阅者使用sendNext发送信息。而且如果我们不再发送数据，最好在这里执行一次sendCompleted方法，这样的话，信号内部会自动调用对应的方法取消信号订阅。</p><p><strong>RACDisposable</strong>：这个类用于取消订阅信号和清理资源，在信号出现错误或者信号完成的时候，信号会自动调起RACDisposable对象的block方法。在代码中我们也可以看到，创建RACDisposable对象是使用disposableWithBlock方法设置了一个block操作，执行block操作之后，信号就不再被订阅了。</p><p><strong>总结：创建信号就是使用createSignal方法，创建一个信号，并为信号设置了一个didSubscribe属性(也就是一系列订阅者需要做的操作)。</strong></p><h4 id="2-订阅信号"><a href="#2-订阅信号" class="headerlink" title="2.订阅信号"></a>2.订阅信号</h4><p>进入订阅信号的源码我们看到如下代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)subscribeNext:(<span class="keyword">void</span> (^)(<span class="keyword">id</span> x))nextBlock error:(<span class="keyword">void</span> (^)(<span class="built_in">NSError</span> *error))errorBlock completed:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))completedBlock &#123;</span><br><span class="line"> <span class="built_in">NSCParameterAssert</span>(nextBlock != <span class="literal">NULL</span>);</span><br><span class="line"> <span class="built_in">NSCParameterAssert</span>(errorBlock != <span class="literal">NULL</span>);</span><br><span class="line"> <span class="built_in">NSCParameterAssert</span>(completedBlock != <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line"> RACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:errorBlock completed:completedBlock];</span><br><span class="line"> <span class="keyword">return</span> [<span class="keyword">self</span> subscribe:o];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此方法中，我们可以看到订阅信号有两个过程：<br><strong>过程1：使用subscribeNext的方法参数，创建出一个订阅者subscriber。</strong><br><strong>过程2：信号对象执行了订阅操作subscribe，方法中传入参数是刚创建的订阅者。</strong></p><p><strong>注：这也就解释了我们常提起却看不见的订阅者存在哪里的问题。真实开发中我们只关心订阅者需要发送的值就行了，而不需要关心其内部订阅的过程。</strong></p><p>继续打开信号的subscribe方法，看到源码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)subscribe:(<span class="keyword">id</span>&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line"> <span class="built_in">NSCParameterAssert</span>(subscriber != <span class="literal">nil</span>);</span><br><span class="line"> RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line"> subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:<span class="keyword">self</span> disposable:disposable];</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">self</span>.didSubscribe != <span class="literal">NULL</span>) &#123;</span><br><span class="line"> RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^&#123;</span><br><span class="line"> RACDisposable *innerDisposable = <span class="keyword">self</span>.didSubscribe(subscriber);</span><br><span class="line"> [disposable addDisposable:innerDisposable];</span><br><span class="line"> &#125;];</span><br><span class="line"> [disposable addDisposable:schedulingDisposable];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> disposable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中我们不难看出：<strong>除了对于订阅者和清理对象的再次封装外，最重要的就是创建信号时为信号设置Block(didSubscribe)被调用了，而且Block参数使用了我们创建的订阅者。</strong></p><h1 id="六、本篇总结"><a href="#六、本篇总结" class="headerlink" title="六、本篇总结"></a>六、本篇总结</h1><p>1.自创建信号会传入一个Block(didSubscribe)，Block中遵循协议的订阅者会调用sendNext方法发送消息。而在订阅信号subscribeNext时，会在内部创建一个订阅者，并将其传递给原先赋值的didSubscribe，并执行这个Block。</p><p>2.<strong>但是我们应该注意</strong>：上述的分析只是其中信号机制的一种情况罢了。RAC对于UI组件信号的封装可能有所不同，比如之前我们看到的输入框信号，执行订阅信号subscribeNext时并不立即执行打印，而是监听到输入时打印。这其实是该信号使用了concat又做了一系列的操作。<strong>对于不同的信号我们只需要理解上述分析中提到几个关键属性，就可以结合源码很好的理解信号机制的使用了。</strong></p><p>本篇的重点在于对RAC的基本介绍，是为了更好的理解信号机制，这仅相当于打开一个切入口来认识RAC。关于RAC的详细用法可以参考下一篇：<a href="https://www.jianshu.com/p/16b4b9d74b7c" target="_blank" rel="noopener">ReactiveCocoa函数响应式编程-应用篇</a>，这里将总结RAC关于信号的各种用法。</p><p>其他参考链接：<br>1.<a href="http://www.cocoachina.com/ios/20150123/10994.html" target="_blank" rel="noopener">ReactiveCocoa入门教程：第一部分</a><br>2.<a href="https://www.jianshu.com/p/87ef6720a096" target="_blank" rel="noopener">最快让你上手ReactiveCocoa之基础篇</a><br>3.<a href="http://ios.jobbole.com/82356/" target="_blank" rel="noopener">这样好用的ReactiveCocoa,根本停不下来</a><br>4.<a href="https://www.cnblogs.com/zhenw/p/6160931.html" target="_blank" rel="noopener">函数式编程与面向对象的比较</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;目录：&quot;&gt;&lt;a href=&quot;#目录：&quot; class=&quot;headerlink&quot; title=&quot;目录：&quot;&gt;&lt;/a&gt;目录：&lt;/h1&gt;&lt;p&gt;一、了解函数响应式编程&lt;br&gt;二、ReactiveCocoa简介&lt;br&gt;三、ReactiveCocoa集成&lt;br&gt;四、理解什么是信号&lt;br&gt;五、从源码理解RAC的信号机制&lt;br&gt;六、本篇总结&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="ReactiveCocoa" scheme="http://yoursite.com/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title>搭建个人博客网站Github、Hexo与Next</title>
    <link href="http://yoursite.com/2018/02/28/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99Github%E3%80%81Hexo%E4%B8%8ENext/"/>
    <id>http://yoursite.com/2018/02/28/搭建个人博客网站Github、Hexo与Next/</id>
    <published>2018-02-28T06:34:57.000Z</published>
    <updated>2018-08-31T14:34:40.556Z</updated>
    
    <content type="html"><![CDATA[<p>过年回家前在公司的最后一天，说实话有点心不在焉了。整个2017也就这样恍然过去，很多事都来不及回想。在这最后的时间里，想起把自己使用Hexo搭建个人博客网站的流程整理成篇，前段时间为了这个也是找了好多资料，遇到不少坑，将它记录在这里就算是旧年里的最后一个节点，毕竟春节过后新的一年就要真正开始了。</p><p>温馨提示：由于本篇是后期整理的文章，一些在实际操作中遇到的错误可能会遗漏，但都是可以百度到的，当然，我也欢迎大家留言问题，以供完善记录。</p><p>效果展示：<a href="https://dreamcoffeezs.github.io/" target="_blank" rel="noopener">风恣的博客</a><br><a id="more"></a></p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>一、准备工作<br>二、搭建博客(远程与本地)<br>三、发布博客<br>四、更换主题<br>五、博客网站美化<br>六、在不同电脑管理hexo博客<br>七、遇到问题<br>八、其他方案</p><h2 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h2><h4 id="1-了解Hexo"><a href="#1-了解Hexo" class="headerlink" title="1.了解Hexo"></a>1.了解Hexo</h4><p><a href="https://github.com/hexojs/hexo" target="_blank" rel="noopener">Hexo</a>是高效的静态站点生成框架，她基于Node.js。 通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的标签插件来快速的插入特定形式的内容，而且相对于其他框架，Hexo在速度上也有很大优势。</p><h4 id="2-搭建Node-js环境"><a href="#2-搭建Node-js环境" class="headerlink" title="2. 搭建Node.js环境"></a>2. 搭建Node.js环境</h4><p>我们了解到Hexo基于Node.js的，那么我们搭建博客网站首先需要安装Node.js环境。 Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，可以在非浏览器环境下，解释运行 JS 代码。<br>下载地址：<a href="http://nodejs.cn/download" target="_blank" rel="noopener">http://nodejs.cn/download</a><br>测试安装：命令行使用node -v 、mpm -v，查看显示版本号即成功。</p><h4 id="3-安装Hexo博客框架工具"><a href="#3-安装Hexo博客框架工具" class="headerlink" title="3.安装Hexo博客框架工具"></a>3.安装Hexo博客框架工具</h4><p>Hexo是一个建站工具，可以帮助我们快速生成基本的博客文件，安装它需要在控制台下使用如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure></p><p>若报错，请尝试在命令前加上sudo</p><h4 id="4-安装Git版本工具"><a href="#4-安装Git版本工具" class="headerlink" title="4.安装Git版本工具"></a>4.安装Git版本工具</h4><p>Git是目前世界上最流行的分布式版本控制系统，是的，没有之一。使用Git可以帮助我们把本地的网页和文章等内容提交到Gihub上，实现同步。<br>下载地址：<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a><br>Windows系统需下载，Mac系统因为自带Git无需操作。<br>测试安装：git  - -version，查看显示版本号即成功。</p><h4 id="5-注册Github账号"><a href="#5-注册Github账号" class="headerlink" title="5.注册Github账号"></a>5.注册Github账号</h4><p>gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。这里用到Github，是因为我们需要通过Github得到自己的博客网站域名，而且需要使用gitHub同步我们个人博客的相关文件。<br>注册地址：<a href="https://github.com" target="_blank" rel="noopener">https://github.com</a><br>注册流程：<a href="https://www.baidu.com" target="_blank" rel="noopener">https://www.baidu.com</a>，百度一下，你就知道啦。</p><p>注意：注册Github的时候一定要选择一个合适的名字，因为后来博客网站的域名也会用到这个名字。虽然Github用户名支持后期修改，但是还是会带来很多不必要的麻烦。github的使用在网上有很多教程，这里也就不再累述了。</p><h2 id="二、开始搭建博客"><a href="#二、开始搭建博客" class="headerlink" title="二、开始搭建博客"></a>二、开始搭建博客</h2><h4 id="1-开启GitHub-Pages服务"><a href="#1-开启GitHub-Pages服务" class="headerlink" title="1.开启GitHub Pages服务"></a>1.开启GitHub Pages服务</h4><p>搭建我们的个人博客需要一个唯一的域名，当然我们可以申请购买一个域名来使用，但是在不是太必要的情况下，我们也可以通过Github Pages获得一个免费使用的域名，这需要我们在Github上新建一个仓库，如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/1244124-7ab2930306e23157.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="Create a new repository"></p><p>这个过程和建立普通的仓库没什么区别，关键在于新仓库的名字，一定要是UserName+“github.io”的形式。这也是之前强调的要起一个好的用户名的原因。这样之后我们最后的博客网站的链接就会是：<a href="http://dreamcoffeezs.github.io" target="_blank" rel="noopener">https://UserName.github.io</a>的形式。<br>注意：固定新仓库的名字格式并非必须，只是这样操作生成的博客域名比较短小简洁，另起他名生成博客域名会很冗长。</p><p>点击Create Repository之后，随后选择Setting进入设置，找到Github Pages如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/1244124-5e0f79282ae8140c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="Github Pages"></p><p>这里我们需要点击Choose a theme任意选择一个选择主题，然后界面会跳转到仓库，我们看到有两个文件如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/1244124-75e5fceb23b7b85a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="屏幕快照 2018-02-07 下午2.45.24.png"></p><p>此时若再查看setting，我们会看到开启GitHub Pages之后得到的域名如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/1244124-685aeb93cbe41235.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="image.png"></p><p>现在，我们就可以使用<a href="https://dreamcoffeezs.github.io" target="_blank" rel="noopener">https://UserName.github.io</a>，访问自己的博客网站了，打开链接我们会看到默认主题的个人博客样式如下(虽然有点点丑，是吧)：</p><p><img src="http://upload-images.jianshu.io/upload_images/1244124-e1b205aeaf1442b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="image.png"></p><h4 id="2-创建本地博客站点"><a href="#2-创建本地博客站点" class="headerlink" title="2.创建本地博客站点"></a>2.创建本地博客站点</h4><p>上述的步骤相当于我们使用Github page，创建了一个默认的博客页，并且得到了一个可外部访问的域名。但是这个博客页很Low。我们的目的是创建自己个性化的博客网站，所以我们使用Hexo在本地先创建一个本地博客站点，优化后再把它部署到github上。接下来我们使用控制台命令在本地一个合适的位置创建博客站点文件夹如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init  myHexoBlog       //myHexoBlog是项目名</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/1244124-8f17110330f1d146.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>下面来测试本地博客站点，在本地博客根目录下使用控制台命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo g  //g是generetor的缩写，生成博客</span><br><span class="line"></span><br><span class="line">hexo s  //s是server的缩写，启动服务</span><br></pre></td></tr></table></figure></p><p>此时打开浏览器，输入 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a>，我们将会看到Hexo自带默认主题显示的博客样式如下(呃，是好看了那么一点点)：<br><img src="http://upload-images.jianshu.io/upload_images/1244124-3e96fc83cdb07011.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt></p><h4 id="3-同步Github-允许公共访问"><a href="#3-同步Github-允许公共访问" class="headerlink" title="3.同步Github,允许公共访问"></a>3.同步Github,允许公共访问</h4><p>在本地我们已经搭建了博客，但是还只能自己本地访问。若要别人也能看到，那就需要我们将其同步部署到GitHub上了。还记得我们之前准备的Github仓库吗，这里就要用到了。<br>首先找到我们的博客仓库，并拷贝仓库地址：</p><p><img src="http://upload-images.jianshu.io/upload_images/1244124-467d7e51b973d1c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt></p><p>然后修改本地博客目录的配置：<br>修改本次博客根目录下的_config.yml文件，修改deploy下的配置如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/1244124-32a2a2a1b31ffc24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt><br>最后执行控制台命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git —save //安装部署插件</span><br><span class="line"></span><br><span class="line">hexo d //部署到github</span><br></pre></td></tr></table></figure></p><p>现在，我们再次访问链接：<a href="https://dreamcoffeezs.github.io" target="_blank" rel="noopener">https://userName.github.io</a>，就会发现这里的界面和本地的一样了。如此一来我们搭建的个人博客网站就基本完成了。</p><h2 id="三、发布博客"><a href="#三、发布博客" class="headerlink" title="三、发布博客"></a>三、发布博客</h2><p>激动人心的时候到了，终于可以发布自己的第一篇博客了。来尝试一下以下的步骤：<br>在本地博客文件夹根目录输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;我个人博客的第一篇博客，哈哈哈...&quot;</span><br><span class="line"></span><br><span class="line">hexo g   //生成网页</span><br><span class="line"></span><br><span class="line">hexo d  //部署到远端(github)</span><br></pre></td></tr></table></figure></p><p>查看我们本地的博客文件夹，将会看到我们创建一个条新的博客文章：</p><p><img src="http://upload-images.jianshu.io/upload_images/1244124-214d608a5c3be183.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="image.png"></p><p>现在打开我们的博客网站：<a href="http://UserName.github.io" target="_blank" rel="noopener">http://UserName.github.io</a>,会看到网页如下(显示可能会延时，不如先喝杯茶放松下吧)：</p><p><img src="http://upload-images.jianshu.io/upload_images/1244124-cbdb263feca887f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt></p><p>这就是我们发布博客的方法啦，当然这里是为了演示，真正做的时候我们要找到_posts里的博客原文，先编辑内容，然后再部署到github上。</p><h2 id="四、更换主题"><a href="#四、更换主题" class="headerlink" title="四、更换主题"></a>四、更换主题</h2><p>现在我们已经看见个人博客的雏形了，但是现在的博客网页一点也不高大上。为了让它看起来更美观一些，我们可以为其更换主题（当然也可以自己在默认主题下自己编写美化博客界面，可是我还不太会前端，以后再突破吧）。这里以使用github上的next主题为例：</p><h4 id="1-创建next文件夹"><a href="#1-创建next文件夹" class="headerlink" title="1.创建next文件夹"></a>1.创建next文件夹</h4><p>切换到本地博客根目录下，在主题文件thems下创建一个新文件夹next存放即将下载的next主题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir themes/next</span><br></pre></td></tr></table></figure></p><h4 id="2-下载主题Next"><a href="#2-下载主题Next" class="headerlink" title="2.下载主题Next"></a>2.下载主题Next</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s [https://api.github.com/repos/iissnan/hexo-theme-next/releases/latest](https://api.github.com/repos/iissnan/hexo-theme-next/releases/latest) | grep tarball_url | cut -d &apos;&quot;&apos; -f 4 | wget -i - -O- | tar -zx -C themes/next --strip-components=1</span><br></pre></td></tr></table></figure><p>此步骤可参考：<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a></p><p>下载成之后我们会看到next的主题已经存在thems里了如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/1244124-c1330c2ff817ab5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt></p><h4 id="3-修改博客配置文件，更换主题配置"><a href="#3-修改博客配置文件，更换主题配置" class="headerlink" title="3.修改博客配置文件，更换主题配置"></a>3.修改博客配置文件，更换主题配置</h4><p>修改博客根目录(不是next主题)下的_config.yml文件，搜索theme字段，并将其值修改为next。</p><p><img src="http://upload-images.jianshu.io/upload_images/1244124-7f63babdcf1a854a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>然后在控制台下输入如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo clean  //清理缓存</span><br><span class="line"></span><br><span class="line">hexo g    //重新生成博客代码</span><br><span class="line"></span><br><span class="line">hexo d   //部署到本地</span><br></pre></td></tr></table></figure></p><p>再次打开我们的博客网站：<a href="https://dreamcoffeezs.github.io" target="_blank" rel="noopener">https://UserName.github.io</a>，将会看到更换主题后的博客网页如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/1244124-892e7a2bcd8b1f39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="屏幕快照 2018-02-07 下午3.50.50.png"></p><h2 id="五、博客网站美化"><a href="#五、博客网站美化" class="headerlink" title="五、博客网站美化"></a>五、博客网站美化</h2><p>终于我们的博客也算像点样子了，如果你和我一样是个完美主义者，那我们来继续美化它吧。这需要我们对博客中的各种配置进行修改。</p><p>首先说明一下：<strong>在Hexo中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。</strong></p><h4 id="1-站点配置："><a href="#1-站点配置：" class="headerlink" title="1.站点配置："></a>1.站点配置：</h4><p>在本地的博客根目录下找到_config.yml，用编辑器打开，如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/1244124-e66dd07f4d17947a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt></p><p>这里可以修改博客网站的标题、描述，语言等属性，上面更换主题也是在这个文件中修改的。大家可以在这里稍作设置。</p><h4 id="2-主题设置"><a href="#2-主题设置" class="headerlink" title="2.主题设置"></a>2.主题设置</h4><p>关于博客主题的配置这块本来想着自己写下呢，却发现官方文档更加详尽。大家可以参考Next文档来学习。<br>文档地址：<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">http://theme-next.iissnan.com/getting-started.html</a><br>其他参考：<br><a href="https://www.jianshu.com/p/f054333ac9e6" target="_blank" rel="noopener">hexo的next主题个性化教程</a><br><a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html#" target="_blank" rel="noopener">打造个性超赞博客Hexo+Next+githubPages的超深度优化</a></p><h4 id="3-更多主题选择"><a href="#3-更多主题选择" class="headerlink" title="3.更多主题选择"></a>3.更多主题选择</h4><p>next只是众多Hexo主题的一种，还有很多优秀的主题可供我们选择，参考以上的更换及配置方法我们就可以进一步美化我们的个人博客网站了。<br>更多主题选择：<a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="noopener">https://github.com/hexojs/hexo/wiki/Themes</a></p><h2 id="六、在不同电脑管理hexo博客"><a href="#六、在不同电脑管理hexo博客" class="headerlink" title="六、在不同电脑管理hexo博客"></a>六、在不同电脑管理hexo博客</h2><p>其实，这也是我在使用Hexo搭建博客遇到的一个问题，如果我们检查自己博客在Github上的文件就会发现，github仓库里的文件和我们本地博客站点的文件夹是不同的，确切来说是少了很多内容。如果我们想在不同的电脑上管理自己的博客，就必须有源文件存在远端供我们随时下载、然后修改后重新部署到远端。</p><p>我们要理解这样一个过程：hexo -d是把本地博客源文件生成的静态网页文件同步到github上，实现部署。但是博客网站的源文件仍需要我们自己保存。这里主要有两种思路可以选择：</p><p>1.在github存放我们博客静态网页文件的仓库里另建分支brach，单独用于存放源文件。<br>2.将本地博客文件存放在<a href="https://gitee.com" target="_blank" rel="noopener">码云</a>上。</p><p>这些都是关于git的操作，所以这里不用细说了。单对于这两种方法来说，我更倾向于第二种。因为毕竟这些都是我们搭建个人博客的源文件，将来还要在网站上发表文章，很多数据都在这里。使用码云我们可以创建私有仓库，将这些源文件私有存放更好一些，而且源文件和静态博客网页文件分开存放也避免使用分支频繁切换。</p><h2 id="七、遇到问题"><a href="#七、遇到问题" class="headerlink" title="七、遇到问题"></a>七、遇到问题</h2><p> ####1.修改了配置，网站没有变化<br> 这种情况，大多因为修改后配置后我们直接部署，没有执行hexo clean。</p><p> ####2.代码无法高亮显示<br> 在Hexo的next主题下，我们使用markDown编辑文章，如果代码无法高亮，这有可能是我们没有在标记语言后添加语言类型，我需要在添加代码片段的时候使用如下的样式：</p><p> <img src="http://upload-images.jianshu.io/upload_images/1244124-77df0d562485c6fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt></p><p> 类似其他语言用：java、python…</p><h2 id="八、其他方案"><a href="#八、其他方案" class="headerlink" title="八、其他方案"></a>八、其他方案</h2><p> 还有一种搭建博客网站的方案是<a href="https://www.jekyll.com.cn" target="_blank" rel="noopener">Jekyll</a>，还没有细致研究呢，先记在这里为以后扩展思路。</p><p> 终于写完了，祝新的一年越来越好，加油！- 2018-02-13</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;过年回家前在公司的最后一天，说实话有点心不在焉了。整个2017也就这样恍然过去，很多事都来不及回想。在这最后的时间里，想起把自己使用Hexo搭建个人博客网站的流程整理成篇，前段时间为了这个也是找了好多资料，遇到不少坑，将它记录在这里就算是旧年里的最后一个节点，毕竟春节过后新的一年就要真正开始了。&lt;/p&gt;
&lt;p&gt;温馨提示：由于本篇是后期整理的文章，一些在实际操作中遇到的错误可能会遗漏，但都是可以百度到的，当然，我也欢迎大家留言问题，以供完善记录。&lt;/p&gt;
&lt;p&gt;效果展示：&lt;a href=&quot;https://dreamcoffeezs.github.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;风恣的博客&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="闲暇所学" scheme="http://yoursite.com/categories/%E9%97%B2%E6%9A%87%E6%89%80%E5%AD%A6/"/>
    
    
      <category term="个人博客" scheme="http://yoursite.com/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="Github" scheme="http://yoursite.com/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>iOS多Target开发相似App</title>
    <link href="http://yoursite.com/2018/02/10/iOS%E5%A4%9ATarget%E5%BC%80%E5%8F%91%E7%9B%B8%E4%BC%BCApp/"/>
    <id>http://yoursite.com/2018/02/10/iOS多Target开发相似App/</id>
    <published>2018-02-10T09:20:47.000Z</published>
    <updated>2018-08-31T14:34:40.556Z</updated>
    
    <content type="html"><![CDATA[<p>我们在iOS开发中可能会遇到同时开发多个类似项目的情况。这些项目大同小异，有诸多代码可以共用，如果每个项目都分别开发，这在后期的迭代中会十分繁琐。为了解决这个问题，使用多Target开发是一种比较好的选择，本文就这一技术实现进行简要总结。<br><a id="more"></a></p><h3 id="一、理解项目中的Porject与Target"><a href="#一、理解项目中的Porject与Target" class="headerlink" title="一、理解项目中的Porject与Target"></a>一、理解项目中的Porject与Target</h3><p>使用Xcode来开发项目，其中的Project是一个整体项目相当于一个仓库，包括了所有的代码和资源文件。而Target相当于一个具体的产品，包含了对于代码，资源文件的具体使用规则和配置。一个Project可以包含多个Target，也就是说通过不同Target我们可以生成不同的APP。</p><h3 id="二、多Target开发项目的实践步骤"><a href="#二、多Target开发项目的实践步骤" class="headerlink" title="二、多Target开发项目的实践步骤"></a>二、多Target开发项目的实践步骤</h3><p>使用多Target来创建项目，就以我当前正在开发的亲戚买房APP为例。需求是这样的：亲戚买房是一个为买房人提供砍价服务的APP，APP的用户需要区分为用户，专家和砍价师三个用户群体。所以这里以Customer，Consul，Bargain三个Target来开发应用</p><ol><li><p>以QQMF(亲戚买房)为名创建一个新的工程如下:<br><img src="http://upload-images.jianshu.io/upload_images/1244124-72d370487e724419.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-11-20 上午11.25.03.png"></p></li><li><p>创建三种Target<br>创建新Target的方式有两种：<br>第一种：依次选择File-&gt;New-&gt;Target，然后选择一个模板(通常是Single View App)来创建。只是这样创建的target带有Appdelegate和main等文件，在这里并不会用到这些文件，所以我们采用第二种方式创建。<br>第二种：<br>在Targets中点击已有的Target，右键选择Duplicate可以复制生成一个<strong>copy的新Target，并且在文件目录中生成对应的</strong>copy-Info.plist文件。这样生成的target与被拷贝的target相似度很大，减少了过多的修改。通常为了减少后期的修改，我们也会首先在原有的Target中修改一些配置之后再Duplicate。<br><img src="http://upload-images.jianshu.io/upload_images/1244124-355533856df44b16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-11-20 上午11.27.06.png"></p></li></ol><p>执行了Duplicate操作之后的效果如下：<br><img src="http://upload-images.jianshu.io/upload_images/1244124-b78642363f7d0a0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-11-20 上午11.29.38.png"></p><ol><li><p>修改Targe和plist文件的名称为自己需要的名称<br>在Target里可以直接修改Target的名称，在文件目录下也可以直接修改plist文件的名称。如果我们不想文件结构那么乱，也可以像其他文件一样移动plist文件的位置并重新引用到工程中，如下：<br><img src="http://upload-images.jianshu.io/upload_images/1244124-ae5e46a7d2c3f927.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-11-20 下午6.35.12.png"><br>特别注意：我们在移动文件的时候可能需要重新引用文件到工程中，此时add文件的时候一定要注意选择Target，如果是共用文件一定要勾选对应的Target，类似AppDelegate这样文件的操作如下：<br><img src="http://upload-images.jianshu.io/upload_images/1244124-8a3839defed21646.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-11-20 下午6.29.01.png"></p></li><li><p>修改Xcode左上角的Target名称<br>选中Xcode左上角的创建工程时的Target(QQMF)，选择Manage schemes<br><img src="http://upload-images.jianshu.io/upload_images/1244124-63a550909a0a2bbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-11-20 下午6.38.06.png"><br>在如下的schemes中修改Target的名称，这里也可以删除多余的最初的QQMF<br><img src="http://upload-images.jianshu.io/upload_images/1244124-a9d8cd9d9082380d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-11-20 上午11.47.18.png"></p></li></ol><p>特别说明：QQMF是我们创建工程自带的Target,其实也可以修改它的名字以供自定义使用，而这里我们是直接删掉了它，这样之后，项目自带的info.plist也是没用的了，也可以删掉。</p><ol><li><p>设置Target与plist文件对应<br>切换到Target目录下，我们可以在这里删掉用不到的QQMF，选择其中一个Target之后并选择general，然后可以看到每个Target的右侧都有对应的choose info.plist file选项，点击可以选择与Target对应的plist文件。这也就相当于不同的Target项目对应了不同的plist配置。<br><img src="http://upload-images.jianshu.io/upload_images/1244124-3d5dfd16700ceb2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-11-20 下午2.01.27.png"></p></li><li><p>为每个Target设置Display Name，Bundle Identifier等信息<br>点击Target-&gt;选择General，我们分别设置不同项目的名称和BundleID信息，以及证书等<br><img src="http://upload-images.jianshu.io/upload_images/1244124-3db248a3e49c6a4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-11-20 下午2.28.17.png"></p></li><li><p>同一份代码区分不同Target的操作<br>使用多Target是为了共用一部分代码，但是有些共用的文件在不同的Target下是有细微不同的，那么我们在具体实现的时候就需要作出区分。这里解决的方法是针对不同的Target定义宏。<br>首先选择一个Target,如Customer，依次选择Build Settings -&gt;搜索PreprocessorMacros,  在找到PreprocessorMacros之后，我们分别在Debug和Release中设置TargetType=1如下图进行设置：<br><img src="http://upload-images.jianshu.io/upload_images/1244124-afb7d7a92379c410.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-11-20 下午6.45.35.png"></p></li></ol><p>其他的Target也是同样的设置方式，只是要区分TargetType的值，分别是2，3(TargetType及其值都是自定义的)。然后就是在代码中的使用如下图，分别选择Xcode左上角不同的Target运行，查看控制台验证是否成功。</p><p><img src="http://upload-images.jianshu.io/upload_images/1244124-f24686677a7e4cdb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-11-20 下午6.55.02.png"></p><ol><li>解决使用Cocoapods的问题<br>因为存在多个Target，我们需要区别的设置不同target需要的第三方库，如下图。这里可能出现的问题是如果有很多类似AFNetworking这样的被多个Target需要的类库，我们在删除和增加的时候就会频繁的操作而且会代码冗余。<br><img src="http://upload-images.jianshu.io/upload_images/1244124-f010d430c1b3426b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-11-20 下午7.22.34.png"><br>解决上述问题的比较优雅的做法是如下：<br><img src="http://upload-images.jianshu.io/upload_images/1244124-9d2efd2a48a3c8f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-11-20 下午7.39.25.png"></li></ol><h3 id="三、遇到的问题"><a href="#三、遇到的问题" class="headerlink" title="三、遇到的问题"></a>三、遇到的问题</h3><ol><li>问题：invalid token at start of a preprocessor expression<br>原因：这是我在pch文件中判断target类型出现的错误，这句话的大致意思是：在预编译阶段，代码并未运行，无法判断宏定义的值。最后查找到原因是我在上述步骤设置宏定义的时候，手误设置了TargetType==1，这本是一句需要执行才能得到结果的代码。所以无法在#if的条件编译中通过。<br>解决：在条件编译中不使用代码运行时才生成的量即可。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在iOS开发中可能会遇到同时开发多个类似项目的情况。这些项目大同小异，有诸多代码可以共用，如果每个项目都分别开发，这在后期的迭代中会十分繁琐。为了解决这个问题，使用多Target开发是一种比较好的选择，本文就这一技术实现进行简要总结。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="移动开发" scheme="http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发中的CPU架构问题</title>
    <link href="http://yoursite.com/2018/02/10/iOS%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84CPU%E6%9E%B6%E6%9E%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/02/10/iOS开发中的CPU架构问题/</id>
    <published>2018-02-10T09:15:04.000Z</published>
    <updated>2018-08-31T14:34:40.556Z</updated>
    
    <content type="html"><![CDATA[<p>首先，之所以提到CPU架构的问题，其实是因为我们iOS开发使用的静态库与动态库与之紧密相连。每一个开发的App都要运行在模拟器或者真机上，在编译的时候，Xcode需要去分析当前运行平台的CPU架构，然后确定所使用的静态库是否支持这个CPU架构。如果不支持就会报错。<br><a id="more"></a></p><h4 id="一、什么是CPU架构"><a href="#一、什么是CPU架构" class="headerlink" title="一、什么是CPU架构"></a>一、什么是CPU架构</h4><p>“CPU架构是CPU厂商给属于同一系列的CPU产品定的一个规范，主要目的是为了区分不同类型CPU的重要标示。目前市面上的CPU分类主要分有两大阵营，一个是intel、AMD为首的复杂指令集CPU，另一个是以IBM、ARM为首的精简指令集CPU。两个不同品牌的CPU，其产品的架构也不相同，例如，Intel、AMD的CPU是X86架构的，而IBM公司的CPU是PowerPC架构，ARM公司是ARM架构”（摘自百度）<br>通常，我们知道电脑的CPU架构有X86和X64等，但是手机的主流CPU架构是ARM架构，因为采用ARM架构的CPU是一种微处理器，这种处理器功耗低，体积小，更适合手机使用，iPhone的CPU也是如此。</p><h4 id="二、iPhone移动设备默认指令集"><a href="#二、iPhone移动设备默认指令集" class="headerlink" title="二、iPhone移动设备默认指令集"></a>二、iPhone移动设备默认指令集</h4><p>那么，总结iPhone设备默认指令集的使用情况如下：<br><img src="http://upload-images.jianshu.io/upload_images/1244124-664cd726a222f057.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2016-11-08 下午1.57.51.png"></p><p>####三、有关指令集使用特点</p><ol><li>上述arm处理器指令集，在原则上它们都是向下兼容的。比如iPhone6s的CPU默认指令集是arm64,但是也同时支持armv7s等以前版本的指令集，只是效率变低了而已。</li><li>xcode模拟器其实是在电脑上的，所以iOS模拟器并没有使用arm指令集。它编译运行使用的是x86指令集(或者i386)。而在真机上使用的才是arm类型的指令集。</li><li>在Xcode中设置二进制包所支持的指令集，对于编译后的二进制包的大小影响显著，设置支持的指令集个数越少，安装包也越小。</li></ol><p>####四、Xcode中关于指令集的配置与使用<br>具体在Xcode中的使用，我们在Xcode中选择将要设置的target，然后打开build setting, 可以看到有关指令集设置的Architectures选项。</p><p><img src="http://upload-images.jianshu.io/upload_images/1244124-3dbf57149752a2ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2016-11-08 下午1.59.51.png"><br>在这里的关键设置有三个，可以通过这里设置Xcode生成二进制包的指令集</p><h6 id="1-Architectures"><a href="#1-Architectures" class="headerlink" title="1.Architectures:"></a>1.Architectures:</h6><p>作用：设置工程被编译后将支持哪些指令集，支持指令集是通过编译生成对应的二进制数据包实现的。<br>特点：设置支持的指令集数据越多，编译出的二进制包包含的指令集代码越多，这样就会使最后编译的包很大。</p><p>######2.valid Architectures：<br>作用：设置可能支持的指令集，这里的指令集选项和Architectures列表中指令集选项的交集，将决定最后Xcode生成二进制包所支持的指令集。<br>举例：Architectures支持armv7, Valid Architecture支持armv7、armv7s、armv64，那么Xcode只会生成一个armv7指令集的二进制包。</p><p>######3.build Active Architecture only<br>作用：设置是否只编译当前使用设备所对应的arm指令集。也就是说当该项设置为YES的时候，上述规则(Architectures和valid Architectures交集决定二进制包所支持指令集)将被打破。<br>举列：设置该选项是YES,并且连接一个armv7指令集设备，无论前面两项如何设置，Xcode最终生成armv7指令集的二进制包。不过设置为YES生效有个前提条件就是，Xcode必须成功连接了调试的设备。</p><h6 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h6><p>一般的情况下，build Active Architecture only选项默认在Debug模式下是YES, Release模式下是NO，但是我们在开发的时候，有时候也会遇到一些第三方文件找不到路径的问题，这时要求我们设置Debug模式下也为NO。</p><h4 id="五、遇到的问题"><a href="#五、遇到的问题" class="headerlink" title="五、遇到的问题"></a>五、遇到的问题</h4><p>在这里记录一个在开发中遇到的问题。曾经在使用CocoaPods管理第三方的时候，遇到了“library not found for -lXXX”的错误，当时使用了Masonry的库。Xcode报错如下：<br><img src="http://upload-images.jianshu.io/upload_images/1244124-7aa56c2371dbf81d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2016-11-08 下午2.25.33.png"><br>其实这是因为CocoaPods在引入第三方类库的时候，默认build Active Architecture only在Debug模式下是YES导致的，修改为NO就可以了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先，之所以提到CPU架构的问题，其实是因为我们iOS开发使用的静态库与动态库与之紧密相连。每一个开发的App都要运行在模拟器或者真机上，在编译的时候，Xcode需要去分析当前运行平台的CPU架构，然后确定所使用的静态库是否支持这个CPU架构。如果不支持就会报错。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="移动开发" scheme="http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
      <category term="架构" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="CPU" scheme="http://yoursite.com/tags/CPU/"/>
    
  </entry>
  
  <entry>
    <title>Charles抓包HTTP、HTTPS</title>
    <link href="http://yoursite.com/2018/02/10/Charles%E6%8A%93%E5%8C%85HTTP%E3%80%81HTTPS/"/>
    <id>http://yoursite.com/2018/02/10/Charles抓包HTTP、HTTPS/</id>
    <published>2018-02-10T08:16:49.000Z</published>
    <updated>2018-08-31T14:34:40.554Z</updated>
    
    <content type="html"><![CDATA[<p>抓包分析数据在移动开发中十分重要，可以帮助我们更快的了解数据构成，提高开发效率。但是在苹果要求上线的App必须使用HTTS之后，HTTPS数据包的抓取分析较为麻烦，在此总结了在mac上使用Charles抓包的详细步骤。</p><p>首先我们下载最先版本的Charles<br>官网下载：<a href="https://www.charlesproxy.com/download/" target="_blank" rel="noopener">https://www.charlesproxy.com/download/</a><br>免费版下载：<a href="http://xclient.info/search/s/charles/" target="_blank" rel="noopener">http://xclient.info/search/s/charles/</a><br><a id="more"></a></p><h2 id="一、开启网络请求记录，设置系统网络代理"><a href="#一、开启网络请求记录，设置系统网络代理" class="headerlink" title="一、开启网络请求记录，设置系统网络代理"></a>一、开启网络请求记录，设置系统网络代理</h2><p>安装Charles之后，我们选择Proxy-&gt;Start Recording，开始记录网络请求，然后勾选MacOS Proxy(和其他的代理对象如：Mozilla Firefox Proxy火狐浏览器）,将系统代理设置通过Charles Proxy。</p><p><img src="http://upload-images.jianshu.io/upload_images/1244124-1e102569baeb07af?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="这里写图片描述"></p><p>此时打开系统偏好设置-&gt;网络-&gt;高级，我们可以看到本机HTTP和HTTPS请求被代理到127.0.0.1，端口号是8888。至此，我们已经完成了基本的网路请求设置，通过此Mac发起的HTTP请求，我们都可以通过Charles分析。</p><p><img src="http://upload-images.jianshu.io/upload_images/1244124-33e1d1bfc220ab1b?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="这里写图片描述"></p><p>注：在Charles关闭的时候，这里的web代理和安全web代理也会变成无勾选状态。保证无代理时，Mac也能够访问网络。</p><h2 id="二、iPhone数据包的抓取"><a href="#二、iPhone数据包的抓取" class="headerlink" title="二、iPhone数据包的抓取"></a>二、iPhone数据包的抓取</h2><h4 id="1-打开Charles的代理功能"><a href="#1-打开Charles的代理功能" class="headerlink" title="1.打开Charles的代理功能"></a>1.打开Charles的代理功能</h4><p>为了使用Charles抓取到iPhone设备的数据包，我们首先要打开Charles的代理功能。选择Proxy -&gt;Proxy Setting，设置Port:8888，选择Enable TransParent HTTP Proxying。</p><p><img src="http://upload-images.jianshu.io/upload_images/1244124-6c21a8f2c7faee79?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="这里写图片描述"></p><h4 id="2-获取本机电脑IP"><a href="#2-获取本机电脑IP" class="headerlink" title="2.获取本机电脑IP"></a>2.获取本机电脑IP</h4><p>接下来我们要将手机的网络代理IP设置为Charles运行所在的电脑IP，获取本机电脑的IP方法如下：<br>方法一：Mac电脑上使用Control +空格键，并输入Terminal 可以进入控制台，然后键入 ifconfig en0命令 ，我们查看到当前电脑的IP地址。</p><p><img src="http://upload-images.jianshu.io/upload_images/1244124-f4824f4de52c2055?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="这里写图片描述"></p><p>方法二：通过Charles查看本机的IP地址：打开Charles -&gt;Help-&gt;Local IP Address</p><p><img src="http://upload-images.jianshu.io/upload_images/1244124-0ee7a9fb94f18a45?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="这里写图片描述"></p><h4 id="3-设置手机网络代理IP"><a href="#3-设置手机网络代理IP" class="headerlink" title="3. 设置手机网络代理IP"></a>3. 设置手机网络代理IP</h4><p>我们依次打开iphone “设置-&gt;无线局域网”，点击当前连接Wifi右侧的详情按钮。这里显示了当前连接Wifi的基本信息，我们需要将这里底部的HTTP代理改为手动，然后填上Charles运行所在电脑的IP和端口号8888。如图：<br><img src="http://upload-images.jianshu.io/upload_images/1244124-f783e5356c3885f6?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="这里写图片描述"></p><p>此时，iPhone的网络代理就设置完成了，手机上请求将会被代理到mac上，我们可以很方便的通过Charles查看到手机应用发起的网络请求数据包。</p><h2 id="三、抓取HTTPS数据包"><a href="#三、抓取HTTPS数据包" class="headerlink" title="三、抓取HTTPS数据包"></a>三、抓取HTTPS数据包</h2><p>相对于HTTP类的网络请求，HTTPS请求更加安全，这也使得抓取这类的数据包进行分析要麻烦一些。抓取HTTPS请求数据包进行分析，关键的步骤如下：</p><h4 id="1-安装Charles根证书"><a href="#1-安装Charles根证书" class="headerlink" title="1.安装Charles根证书"></a>1.安装Charles根证书</h4><p>打开charles,依次点击Help -&gt; SSL Proxying -&gt; Install Charles Root Certificate，安装根证书</p><p><img src="http://upload-images.jianshu.io/upload_images/1244124-04d82ed6515f81b1?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="这里写图片描述"></p><h4 id="2-设置证书信任"><a href="#2-设置证书信任" class="headerlink" title="2.设置证书信任"></a>2.设置证书信任</h4><p>在安装证书之后，我们查看钥匙串。选择所有项目，我们会看到一个带有红叉标记不被信任的Charles证书。Charles证书默认是不信任的，需要我们手动设置。右键-&gt;显示简介-&gt;点击信任，我们如图设置始终信任。</p><p><img src="http://upload-images.jianshu.io/upload_images/1244124-b4a018da38edecc0?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="这里写图片描述"></p><h4 id="3-设置-SSL-代理"><a href="#3-设置-SSL-代理" class="headerlink" title="3.设置 SSL 代理"></a>3.设置 SSL 代理</h4><p>打开charles应用，选择Proxy-&gt;SSL Proxying Settings,我们在这里设置SSL Proxy,点击面板上的add，如下图：</p><p><img src="http://upload-images.jianshu.io/upload_images/1244124-e3955f415befd14d?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="这里写图片描述">在这里我们设置主机地址Host是*,使用通配符表示检测所有网络请求。然后设置端口号是443</p><h4 id="4-iOS设备安装证书"><a href="#4-iOS设备安装证书" class="headerlink" title="4.iOS设备安装证书"></a>4.iOS设备安装证书</h4><p>最后我们还需要在iOS设备上安装证书。点击 Charles 的顶部菜单，选择 Help –&gt; SSL Proxying–&gt; Install Charles Root Certificate on a Mobile Device or Remote Browser，然后就可以看到 Charles 显示如下弹窗：</p><p><img src="http://upload-images.jianshu.io/upload_images/1244124-b99d87289ffa281f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="屏幕快照 2017-01-09 下午2.18.11.png"></p><p>然后我们需要打开safari ,输入网址： <a href="http://charlesproxy.com/getssl，" target="_blank" rel="noopener">http://charlesproxy.com/getssl，</a><br>这时候会弹出安装证书的界面，我们点击安装证书，如图：<br><img src="http://upload-images.jianshu.io/upload_images/1244124-8bf445a572b2f7e8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里写图片描述"><br>目前为止，我们就完成了Charles抓取HTTPS数据包的所有设置了。查看Charles,我们可以看到数据包的内容了。</p><h4 id="5-失败请求的处理"><a href="#5-失败请求的处理" class="headerlink" title="5.失败请求的处理"></a>5.失败请求的处理</h4><p>iOS10.3之后，在上述设置完成之后，所有的https请求都会失败。提示错误：Failure SSLHandshake: Received fatal alert: unknown_ca 和You may need to configure your browser or application to trust the Charles Root Certificate.<br>原因：charles的根证书虽然已经在安装列表中,但在iOS 10.3之后,安装新的自定义证书默认是不受信任的。如果要信任已安装的自定义证书,需要手动打开开关以信任证书。<br>解决：设置-&gt;通用-&gt;关于本机-&gt;证书信任设置-&gt; 找到charles proxy custom root certificate然后信任该证书即可. 模拟器也是这样处理。</p><h4 id="四、使用Charles遇到的问题"><a href="#四、使用Charles遇到的问题" class="headerlink" title="四、使用Charles遇到的问题"></a>四、使用Charles遇到的问题</h4><p>我在使用Charles抓包https之后，在使用applicationLoader上传ipa包的时候遇到了下面的问题：<br>Communication error. Please use diagnostic mode to check connectivity. You need to have outbound access to TCP port 443.</p><p><img src="http://upload-images.jianshu.io/upload_images/1244124-d3fb57a7e92f23ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="屏幕快照 2017-01-11 下午5.14.08.png"></p><p>解决：将charles关闭，然后再上传ipa文件。<br>至于原因我也没弄明白，如果哪位朋友知道也可以告诉我一下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;抓包分析数据在移动开发中十分重要，可以帮助我们更快的了解数据构成，提高开发效率。但是在苹果要求上线的App必须使用HTTS之后，HTTPS数据包的抓取分析较为麻烦，在此总结了在mac上使用Charles抓包的详细步骤。&lt;/p&gt;
&lt;p&gt;首先我们下载最先版本的Charles&lt;br&gt;官网下载：&lt;a href=&quot;https://www.charlesproxy.com/download/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.charlesproxy.com/download/&lt;/a&gt;&lt;br&gt;免费版下载：&lt;a href=&quot;http://xclient.info/search/s/charles/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://xclient.info/search/s/charles/&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="开发工具" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="开发工具" scheme="http://yoursite.com/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
      <category term="移动开发" scheme="http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="抓包" scheme="http://yoursite.com/tags/%E6%8A%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>iOS与JS交互</title>
    <link href="http://yoursite.com/2018/02/09/iOS%E4%B8%8EJS%E4%BA%A4%E4%BA%92/"/>
    <id>http://yoursite.com/2018/02/09/iOS与JS交互/</id>
    <published>2018-02-09T04:10:25.000Z</published>
    <updated>2018-08-31T14:34:40.555Z</updated>
    
    <content type="html"><![CDATA[<p>iOS和JS的交互看似两个问题，其实要解决的问题只有一个，那就是JS如何调用native方法。因为查询文档我们就可以发现，在UIWebView中，native有直接调用JS的方法, 但是JS却没有直接调用native的方法。<br><a id="more"></a></p><h3 id="一、native直接调用js的方法："><a href="#一、native直接调用js的方法：" class="headerlink" title="一、native直接调用js的方法："></a>一、native直接调用js的方法：</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="built_in">NSString</span>*)stringByEvaluatingJavaScriptFromString</span><br><span class="line">:(<span class="built_in">NSString</span> *)script;</span><br></pre></td></tr></table></figure><h3 id="二、JS直接调用native的方法"><a href="#二、JS直接调用native的方法" class="headerlink" title="二、JS直接调用native的方法"></a>二、JS直接调用native的方法</h3><p>其实，UIWebView并没有提供JS调用native的方法，但是我们却可以通过间接的方法来实现这样的操作。总结看来，间接实现的方式有4种：</p><ol><li>在代理方法拦截Url,识别判断</li><li>Block传值,实现JS调用OC</li><li>模型实现，JS直接用oc方法名来调用oc方法</li><li>使用第三方工具类：WebViewJavascriptBridge<br>下面就来简单介绍一下上述方法的简单实用<br>####1.在代理方法拦截Url,识别判断<br>这种方法原理很简单，UIWebView的界面响应会调起下面的代理方法<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)webView:(<span class="built_in">UIWebView</span> *)webView</span><br><span class="line">shouldStartLoadWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">navigationType:(<span class="built_in">UIWebViewNavigationType</span>)navigationType;</span><br></pre></td></tr></table></figure></li></ol><p>在该方法中我们可以识别网页链接中的特殊字段，从而达到JS调起原生方法的目的<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一步：使用本地的h5文件加载一个网页</span></span><br><span class="line"><span class="built_in">NSString</span> *htmlPath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"testWebPage"</span> ofType:<span class="string">@"html"</span>];</span><br><span class="line"><span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line"><span class="built_in">NSString</span>  *str = [<span class="built_in">NSString</span> stringWithContentsOfFile:htmlPath encoding:<span class="built_in">NSUTF8StringEncoding</span> error:&amp;error];</span><br><span class="line">[<span class="keyword">self</span>.webView loadHTMLString:str baseURL:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//h5文件中JS关键代码如下：</span></span><br><span class="line">&lt;p &gt;</span><br><span class="line">&lt;button <span class="keyword">id</span>=<span class="string">"chat"</span> type=<span class="string">"button"</span> onclick=<span class="string">"location.href    ='http://www.testwebpage/?</span></span><br><span class="line">funcName=printInfo:&amp;&amp;info=helloword'"&gt;打印信息&lt;/button&gt;</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二步：拦截协议</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)webView:(<span class="built_in">UIWebView</span> *)webView shouldStartLoadWithRequest:(<span class="built_in">NSURLRequest</span> *)request navigationType:(<span class="built_in">UIWebViewNavigationType</span>)navigationType&#123;</span><br><span class="line"><span class="comment">//获取此时的URL</span></span><br><span class="line"><span class="comment">//'http://www.testwebpage/?funcName=printInfo:&amp;&amp;info=helloword'</span></span><br><span class="line"><span class="built_in">NSURL</span> *url = [request URL];</span><br><span class="line"><span class="built_in">NSString</span> *completeString = [url absoluteString];</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一步:检测链接中的特殊字段</span></span><br><span class="line"><span class="built_in">NSString</span> *needCheckStr = <span class="string">@"http://www.testwebpage/?"</span>;</span><br><span class="line"><span class="built_in">NSRange</span> jumpRange = [completeString rangeOfString:needCheckStr];</span><br><span class="line"><span class="keyword">if</span> (jumpRange.location != <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.检测到链接中包含有特殊字段，客户端要接受响应并做后续处理这就相当于js调起了iOS，</span></span><br><span class="line"><span class="comment">2.在真实的使用时，客户端需要和h5协调，双方需要统一监听的字段</span></span><br><span class="line"><span class="comment">3.参数问题：如果此时的交互需要传递参数，参数也可以放在链接里，同样通过识别字符串的方法来获取</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//第二步：拿到链接字符串的后续部分，然后分割字符串得到参数数据</span></span><br><span class="line"><span class="built_in">NSMutableString</span> *linkmStr = [<span class="built_in">NSMutableString</span> stringWithString:completeString];</span><br><span class="line"><span class="built_in">NSRange</span> deleteRange = &#123;<span class="number">0</span>,needCheckStr.length&#125;;</span><br><span class="line">[linkmStr deleteCharactersInRange:deleteRange];</span><br><span class="line"><span class="built_in">NSArray</span> *params = [linkmStr componentsSeparatedByString:<span class="string">@"&amp;&amp;"</span>];</span><br><span class="line"><span class="comment">//取出第一个参数：与h5协商好的方法名</span></span><br><span class="line"><span class="built_in">NSString</span> *funcName = [params[<span class="number">0</span>] componentsSeparatedByString:<span class="string">@"="</span>][<span class="number">1</span>];</span><br><span class="line"><span class="comment">//取出第二个参数：信息字符串</span></span><br><span class="line"><span class="built_in">NSString</span> *info = [params[<span class="number">1</span>] componentsSeparatedByString:<span class="string">@"="</span>][<span class="number">1</span>];</span><br><span class="line"><span class="comment">//第三步：调起iOS原生方法</span></span><br><span class="line">SEL ocFunc = <span class="built_in">NSSelectorFromString</span>(funcName);</span><br><span class="line"><span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:ocFunc]) &#123;</span><br><span class="line"><span class="comment">//使用编译预处理，不显示警告提示</span></span><br><span class="line"><span class="meta">#pragma clang diagnostic push</span></span><br><span class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Warc-performSelector-leaks"</span></span></span><br><span class="line">[<span class="keyword">self</span> performSelector:ocFunc withObject:info];</span><br><span class="line"><span class="meta">#pragma clang diagnostic pop</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回NO是为了不再执行点击原链接的跳转</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-Block传值-实现JS调用OC"><a href="#2-Block传值-实现JS调用OC" class="headerlink" title="2.Block传值,实现JS调用OC"></a>2.Block传值,实现JS调用OC</h4><p>这种方法需要引入头文件<br>import <javascriptcore javascriptcore.h><br>具体的代码操作如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JS关键代码：</span><br><span class="line">&lt;p&gt;</span><br><span class="line">&lt;button onclick="sayHello('helloword')" type="button"&gt;问候&lt;/button&gt;</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure></javascriptcore></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">OC关键代码：</span><br><span class="line">- (<span class="keyword">void</span>)webViewDidFinishLoad:(<span class="built_in">UIWebView</span> *)webView&#123;</span><br><span class="line"><span class="comment">//获取JSContext对象</span></span><br><span class="line">JSContext *context=[webView valueForKeyPath:<span class="string">@"documentView.webView.mainFrame.javaScriptContext"</span>];</span><br><span class="line"><span class="comment">//sayHello就是js的方法名称，使用一个block对应赋值</span></span><br><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span> (<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">context[<span class="string">@"sayHello"</span>] = ^() &#123;</span><br><span class="line"><span class="built_in">NSArray</span> *args = [JSContext currentArguments];</span><br><span class="line"><span class="built_in">NSString</span> *objString = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@"</span>,args[<span class="number">0</span>]] ;</span><br><span class="line"><span class="keyword">if</span> (objString.length &gt;<span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//得到参数之后，这里可以使用调用OC方法，即实现了JS对于OC的调用</span></span><br><span class="line">[weakSelf printInfo:objString];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-模型实现，JS直接用oc方法名来调用oc方法"><a href="#3-模型实现，JS直接用oc方法名来调用oc方法" class="headerlink" title="3.模型实现，JS直接用oc方法名来调用oc方法"></a>3.模型实现，JS直接用oc方法名来调用oc方法</h4><p>这种方法的优点在于，JS可以直接用oc方法名来调用oc方法，这样就类似于安卓的addJavaScriptInterface方法，在使用此方法时仍然要导入JavaScriptCore</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一步：创建一个用与JS交互的类JSHandler继承与NSObject</span></span><br><span class="line"><span class="comment">//在类中声明一个遵守JSExport的协议，并且使JSHandler实现这个新的协议</span></span><br><span class="line">@protocolJSHandlerProtocol &lt;JSExport&gt;</span><br><span class="line"><span class="comment">//单参数方法</span></span><br><span class="line">- (<span class="keyword">void</span>)sayHello:(<span class="built_in">NSString</span>*)greeting;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多参数的方法</span></span><br><span class="line"><span class="comment">//由于涉及到多参数的问题，从第二个参数开始，外部参数名都要使用大写开头</span></span><br><span class="line"><span class="comment">//因为JS调用OC方法时，是将OC方法拼接连成字符串，如果无法区分就会造成无法识别</span></span><br><span class="line"><span class="comment">//比如对于下面的OC方法，JS调用时</span></span><br><span class="line"><span class="comment">//javascript.sayHelloToWithGreeting(‘参数1’，参数2) //正确写法</span></span><br><span class="line"><span class="comment">//javascript.sayHelloTowithGreeting(‘参数1’，参数2) //错误写法</span></span><br><span class="line">- (<span class="keyword">void</span>)sayHelloTo:(<span class="built_in">NSString</span>*)name WithGreeting:(<span class="built_in">NSString</span>*)greeting;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">JSHandler</span> : <span class="title">NSObject</span>&lt;<span class="title">JSHandlerProtocol</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二步：实现协议方法</span></span><br><span class="line">@implementationJSHandler:<span class="built_in">NSObject</span></span><br><span class="line"><span class="comment">//单参数方法</span></span><br><span class="line">- (<span class="keyword">void</span>)sayHello:(<span class="built_in">NSString</span>*)greeting&#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,greeting);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个参数的方法</span></span><br><span class="line">- (<span class="keyword">void</span>)sayHelloTo:(<span class="built_in">NSString</span>*)name WithGreeting:(<span class="built_in">NSString</span>*)greeting&#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@,%@"</span>,name,greeting);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第三步：在webView所在的视图控制中，创建JSContext对象，使用协议方法</span></span><br><span class="line">JSContext*jsContext = [<span class="keyword">self</span>.webViewvalueForKeyPath:<span class="string">@"documentView.webView.mainFrame.javaScriptContext"</span>];</span><br><span class="line">JSHandler*jsHandler = [JSHandlernew];</span><br><span class="line"><span class="comment">//使jsContext可以识别javascript这个类的方法</span></span><br><span class="line">jsContext[<span class="string">@"javascript"</span>] = jsHandler;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第四步：此步骤是H5部分的操作，能够调起OC方法的代码如下</span></span><br><span class="line">&lt;p&gt;sayHello&lt;buttonid="opennew"type="button"onclick="javascript.sayHello('你好!')"&gt;问候1&lt;/button&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;sayHelloTo&lt;buttonid=<span class="string">"opennew2"</span>type=<span class="string">"button"</span>onclick=</span><br><span class="line">"javascript.sayHelloToWithGreeting('zhoushuai', 'Good morning!')"&gt;问候2&lt;/button&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>####4.使用第三方工具类：WebViewJavascriptBridge<br>还未使用过，暂时不做过多介绍</p><p>Demo的github地址：<br><a href="https://github.com/DreamcoffeeZS/OC-And-JS" target="_blank" rel="noopener">https://github.com/DreamcoffeeZS/OC-And-JS</a><br>参考链接：<br><a href="http://www.cocoachina.com/ios/20160127/15105.html" target="_blank" rel="noopener">http://www.cocoachina.com/ios/20160127/15105.html</a><br><a href="http://www.jianshu.com/p/2c7a53713e13" target="_blank" rel="noopener">http://www.jianshu.com/p/2c7a53713e13</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS和JS的交互看似两个问题，其实要解决的问题只有一个，那就是JS如何调用native方法。因为查询文档我们就可以发现，在UIWebView中，native有直接调用JS的方法, 但是JS却没有直接调用native的方法。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="移动开发" scheme="http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
